<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit Wine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="objects.css">
</head>
<body>
    <button class="mute-button" id="muteButton" title="Toggle Music">ðŸ”Š</button>
    <div class="container">
        <div class="stats-panel panel">
            <div class="credit-display">
                <div class="credit-amount" id="creditAmount">0</div>
                <div class="credit-label">Credits</div>
                <div class="object-level" id="objectLevel">Level 1</div>
            </div>
            <button class="button-base upgrade-button" id="upgradeButton" style="display: none;">Upgrade - 300 Credits</button>
            <button class="button-base refresh-button" id="refreshButton" style="display: none;">Refresh Cooldown</button>
            <button class="button-base subtick-button" id="subtickButton" style="display: none;">Charge Subtick</button>
            <div class="subtick-meter" id="subtickMeter" style="display: none;">Subticks: 0</div>
        </div>
        <div class="objects-panel panel">
            <div class="section-header">
                <div class="section-title">Object</div>
                <button class="discard-button" id="discardButton" style="display: none;">Discard Object</button>
            </div>
            <div class="objects-grid" id="objectsGrid"></div>
        </div>
    </div>
    <div class="feedback" id="feedback"></div>
    <script>
        $(document).ready(function() {
            const CACHE_KEY = 'rabbitobjects_save', MAX_OBJECTS = 4000;
            let state = { credits: 0, objects: [createEmptyObject()], isMuted: false };
            let currentMusicAudio = null, cooldownIntervals = new Map();
            
            function createEmptyObject() {
                return { id: 'master', isEmpty: true, imageNumber: null, level: 1, baseCost: 300, costScaling: 1.5, tickValue: null, breakProbability: null, shatterBonus: null, music: null, breakSfx: null, cooldown: null, lastTicked: null, currentMusic: null, subtickCount: 0 };
            }
            
            function validateSave(saved) {
                try {
                    if (!saved?.objects?.[0] || typeof saved.credits !== 'number' || saved.credits < 0) return false;
                    const obj = saved.objects[0];
                    if (typeof obj.subtickCount !== 'number') obj.subtickCount = 0;
                    if (typeof obj.currentMusic !== 'boolean') obj.currentMusic = false;
                    return true;
                } catch (e) { return false; }
            }
            
            function saveGame() { try { localStorage.setItem(CACHE_KEY, JSON.stringify(state)); } catch(e) {} }
            function loadGame() { try { const saved = JSON.parse(localStorage.getItem(CACHE_KEY)); return validateSave(saved) ? saved : null; } catch(e) { return null; } }
            
            function playAudio(folder, num, vol, isWav, loop = false) {
                if (state.isMuted) return;
                const audio = new Audio(`${folder}/${num}.${isWav ? 'wav' : 'mp3'}`);
                audio.volume = vol; audio.loop = loop;
                audio.play().catch(() => {});
                return audio;
            }
            
            function playMusic(num) { if (currentMusicAudio) currentMusicAudio.pause(); currentMusicAudio = playAudio('corridor', num, 0.15, false, true); }
            function playBreakSfx(num) { playAudio('break', num, 0.25, true); }
            function playTickSfx(num) { playAudio('tick', num, 0.2, false); }
            function playPopSfx() { playAudio('pop', Math.floor(Math.random() * 10) + 1, 0.69, true); }
            function stopMusic() { if (currentMusicAudio) { currentMusicAudio.pause(); currentMusicAudio = null; } }
            
            function toggleMute() {
                state.isMuted = !state.isMuted;
                const $btn = $('#muteButton');
                if (state.isMuted) { stopMusic(); $btn.text('ðŸ”‡').addClass('muted'); }
                else { $btn.text('ðŸ”Š').removeClass('muted'); const obj = state.objects[0]; if (!obj.isEmpty && obj.currentMusic) playMusic(obj.music); }
                saveGame();
            }
            
            function generateObj() {
                return {
                    imageNumber: Math.floor(Math.random() * MAX_OBJECTS), level: 1, baseCost: 300, costScaling: 1.3 + Math.random() * 0.69,
                    tickValue: Math.floor(Math.random() * 11) + 4, breakProbability: Math.floor(Math.random() * 35) + 16,
                    shatterBonus: Math.floor(Math.random() * 420) + 69, music: Math.floor(Math.random() * 39) + 1,
                    breakSfx: Math.floor(Math.random() * 18) + 1, cooldown: Math.floor(Math.random() * 20) + 1,
                    lastTicked: null, currentMusic: false, subtickCount: 0
                };
            }
            
            function getCost(obj, type) {
                const base = type === 'upgrade' ? Math.floor(obj.baseCost * Math.pow(obj.costScaling, obj.level - 1)) : state.credits;
                return type === 'upgrade' ? base : Math.floor(base * (type === 'refresh' ? 10 + obj.level : 15 + obj.level) / 100);
            }
            
            function upgradeObject() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                const cost = getCost(obj, 'upgrade');
                if (state.credits < cost) return;
                
                playPopSfx();
                state.credits -= cost; obj.level++;
                const upgrades = [
                    () => { obj.tickValue = Math.max(2, Math.floor(obj.tickValue * 2.69)) + 25; return 'Tick value increased!'; },
                    () => { obj.breakProbability = Math.max(5, obj.breakProbability - 4); return 'Break chance reduced!'; },
                    () => { obj.shatterBonus = Math.floor(obj.shatterBonus * 2.69); return 'Shatter bonus increased!'; },
                    () => { obj.cooldown = Math.max(2, obj.cooldown - 2); return 'Cooldown reduced!'; }
                ];
                showFeedback(upgrades[Math.floor(Math.random() * 4)](), 'success');
                saveGame(); updateUI();
            }
            
            function refreshCooldown() {
                const obj = state.objects[0];
                if (obj.isEmpty || !isOnCooldown(0)) return;
                const cost = getCost(obj, 'refresh');
                if (state.credits < cost) return;
                
                playPopSfx();
                state.credits -= cost; obj.lastTicked = null;
                clearCooldown(0); updateCooldownDisplay(0);
                showFeedback('Cooldown refreshed!', 'success');
                saveGame(); updateUI();
            }
            
            function chargeSubtick() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                const cost = getCost(obj, 'subtick');
                if (state.credits < cost || cost <= 0) return;
                
                playPopSfx();
                state.credits -= cost; obj.subtickCount++;
                showFeedback('Subtick charged!', 'success');
                saveGame(); updateUI();
            }
            
            function resetObject(obj) {
                Object.assign(obj, createEmptyObject());
            }
            
            function discardObject() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                if (obj.currentMusic) stopMusic();
                clearCooldown(0); playBreakSfx(obj.breakSfx);
                resetObject(obj);
                saveGame(); updateUI(); showFeedback('Object discarded!', 'warning');
            }
            
            function isOnCooldown(idx) {
                const obj = state.objects[idx];
                return obj.lastTicked && (Date.now() - obj.lastTicked) < (obj.cooldown * 1000);
            }
            
            function getCooldownRemaining(idx) {
                const obj = state.objects[idx];
                if (!obj.lastTicked) return 0;
                return Math.max(0, (obj.cooldown * 1000) - (Date.now() - obj.lastTicked));
            }
            
            function clearCooldown(idx) {
                if (cooldownIntervals.has(idx)) { clearInterval(cooldownIntervals.get(idx)); cooldownIntervals.delete(idx); }
            }
            
            function startCooldownTimer(idx) {
                const obj = state.objects[idx];
                if (obj.isEmpty) return;
                clearCooldown(idx);
                const interval = setInterval(() => {
                    if (isOnCooldown(idx)) updateCooldownDisplay(idx);
                    else { clearCooldown(idx); updateCooldownDisplay(idx); }
                }, 100);
                cooldownIntervals.set(idx, interval);
            }
            
            function updateCooldownDisplay(idx) {
                const $slot = $(`.object-slot[data-index="${idx}"]`);
                const remaining = getCooldownRemaining(idx);
                
                if (remaining > 0) {
                    const obj = state.objects[idx];
                    const progress = ((obj.cooldown * 1000 - remaining) / (obj.cooldown * 1000)) * 100;
                    $slot.addClass('cooldown').find('.cooldown-bar').css('width', `${progress}%`);
                    $slot.find('.cooldown-text').text(`${Math.ceil(remaining / 1000)}s`).show();
                } else {
                    $slot.removeClass('cooldown').find('.cooldown-bar').css('width', '0%');
                    $slot.find('.cooldown-text').hide();
                }
            }
            
            function tickObject(idx) {
                const obj = state.objects[idx];
                if (obj.isEmpty || isOnCooldown(idx)) return;
                
                // Process subticks (give credits, no break risk, no SFX)
                if (obj.subtickCount > 0) {
                    state.credits += obj.tickValue * obj.subtickCount;
                    showFeedback(`${obj.subtickCount} subticks: +${obj.tickValue * obj.subtickCount} credits!`, 'success');
                    obj.subtickCount = 0;
                }
                
                // Main tick
                state.credits += obj.tickValue;
                showFeedback(`+${obj.tickValue} credits!`, 'success');
                obj.lastTicked = Date.now();
                startCooldownTimer(idx);
                
                // Check for break
                if (Math.random() * 100 < obj.breakProbability) {
                    state.credits += obj.shatterBonus;
                    showFeedback(`Object shattered! +${obj.shatterBonus} bonus!`, 'warning');
                    playBreakSfx(obj.breakSfx);
                    if (obj.currentMusic) stopMusic();
                    clearCooldown(idx);
                    resetObject(obj);
                } else {
                    playTickSfx((obj.breakSfx % 3) + 1);
                }
                saveGame(); updateUI();
            }
            
            function fillEmptySlot(idx) {
                const obj = state.objects[idx];
                if (!obj.isEmpty) return;
                
                const newObj = generateObj();
                Object.assign(obj, newObj);
                obj.isEmpty = false; obj.currentMusic = true;
                
                // Bonus scaling
                const cooldownBonuses = [5, 15, 25, 35, 45];
                const breakBonuses = [20, 30, 40];
                cooldownBonuses.forEach(threshold => { if (obj.cooldown > threshold) obj.tickValue *= 2; });
                breakBonuses.forEach(threshold => { if (obj.breakProbability > threshold) obj.tickValue *= 2; });
                
                stopMusic(); playMusic(obj.music);
                saveGame(); updateUI(); showFeedback('New object', 'success');
            }
            
            function showFeedback(msg, type = 'success') {
                const $fb = $('#feedback');
                $fb.removeClass('success warning error').addClass(type).text(msg).addClass('show');
                setTimeout(() => $fb.removeClass('show'), 3000);
            }
            
            function updateUI() {
                $('#creditAmount').text(state.credits.toLocaleString());
                const obj = state.objects[0];
                const buttons = { upgrade: $('#upgradeButton'), refresh: $('#refreshButton'), subtick: $('#subtickButton') };
                const $discard = $('#discardButton'), $level = $('#objectLevel'), $meter = $('#subtickMeter');
                
                if (obj.isEmpty) {
                    Object.values(buttons).forEach(btn => btn.hide());
                    $discard.hide(); $meter.hide(); $level.text('Level 1');
                } else {
                    buttons.upgrade.show().text(`Upgrade - ${getCost(obj, 'upgrade').toLocaleString()} Credits`).prop('disabled', state.credits < getCost(obj, 'upgrade'));
                    $discard.show(); $level.text(`Level ${obj.level}`);
                    
                    if (obj.level > 2) {
                        const refreshCost = getCost(obj, 'refresh');
                        buttons.refresh.show().text(`Refresh - ${refreshCost.toLocaleString()} Credits`).prop('disabled', state.credits < refreshCost || !isOnCooldown(0));
                    } else buttons.refresh.hide();
                    
                    if (obj.level > 4) {
                        const subtickCost = getCost(obj, 'subtick');
                        buttons.subtick.show().text(`Charge Subtick - ${subtickCost.toLocaleString()} Credits`).prop('disabled', state.credits < subtickCost || subtickCost <= 0);
                        $meter.show().text(`Subticks: ${obj.subtickCount}`);
                    } else { buttons.subtick.hide(); $meter.hide(); }
                }
                renderSlots();
            }
            
            function renderSlots() {
                const $grid = $('#objectsGrid');
                $grid.empty();
                
                state.objects.forEach((obj, idx) => {
                    const $slot = $('<div>').addClass('object-slot').attr('data-index', idx);
                    
                    if (obj.isEmpty) {
                        $slot.addClass('empty').html('<div>Click for a new object</div>').on('click', () => fillEmptySlot(idx));
                    } else {
                        $slot.addClass('filled');
                        
                        const $img = $('<img>').addClass('object-image').attr('src', `shapes/${obj.imageNumber}.png`).attr('alt', `Object ${obj.imageNumber}`)
                            .on('error', function() { $(this).attr('src', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSIjNGE0YTRhIi8+Cjx0ZXh0IHg9IjUwIiB5PSI1NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzk0YTNiOCIgZm9udC1zaXplPSIxMiI+Tm90IEZvdW5kPC90ZXh0Pgo8L3N2Zz4='); });
                        
                        let stats = `<div class="stat-row"><span class="stat-label">Level:</span><span class="stat-value">${obj.level}</span></div>
                            <div class="stat-row"><span class="stat-label">Tick:</span><span class="stat-value">${obj.tickValue}</span></div>
                            <div class="stat-row"><span class="stat-label">Break:</span><span class="stat-value">${obj.breakProbability}%</span></div>
                            <div class="stat-row"><span class="stat-label">Shatter:</span><span class="stat-value">${obj.shatterBonus}</span></div>
                            <div class="stat-row"><span class="stat-label">Cooldown:</span><span class="stat-value">${obj.cooldown}s</span></div>`;
                        
                        if (obj.subtickCount > 0) stats += `<div class="stat-row"><span class="stat-label">Subticks:</span><span class="stat-value">${obj.subtickCount}</span></div>`;
                        
                        const $stats = $('<div>').addClass('object-stats').html(stats);
                        const $cooldownBar = $('<div>').addClass('cooldown-bar');
                        const $cooldownText = $('<div>').addClass('cooldown-text').hide();
                        
                        $slot.append($img, $stats, $cooldownBar, $cooldownText).on('click', () => {
                            if (!isOnCooldown(idx)) {
                                $slot.addClass('pulsing');
                                setTimeout(() => $slot.removeClass('pulsing'), 500);
                                tickObject(idx);
                            }
                        });
                        
                        updateCooldownDisplay(idx);
                        if (isOnCooldown(idx)) startCooldownTimer(idx);
                    }
                    $grid.append($slot);
                });
            }
            
            function init() {
                const saved = loadGame();
                if (saved) {
                    state = saved;
                    const obj = state.objects[0];
                    if (!obj.isEmpty && obj.currentMusic && !state.isMuted) playMusic(obj.music);
                } else {
                    showFeedback('Save reset - creating new game', 'warning');
                }
                
                const $mute = $('#muteButton');
                $mute.text(state.isMuted ? 'ðŸ”‡' : 'ðŸ”Š')[state.isMuted ? 'addClass' : 'removeClass']('muted');
                
                $mute.on('click', toggleMute);
                $('#upgradeButton').on('click', upgradeObject);
                $('#refreshButton').on('click', refreshCooldown);
                $('#subtickButton').on('click', chargeSubtick);
                $('#discardButton').on('click', discardObject);
                
                updateUI();
                setInterval(saveGame, 5000);
            }
            
            init();
        });
    </script>
</body>
</html>
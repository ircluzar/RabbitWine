<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon.png">
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#1a1626">
    <title>Ask - Rabbit Wine</title>
    <link rel="stylesheet" href="../stickers/styles.css">
    <link rel="stylesheet" href="objects.css">
    <link rel="stylesheet" href="../stars.css">
    <link rel="stylesheet" href="ask.css">
    <script src="../miniPlayer.js"></script>
    <style>
    /* Animation and layout for ask page after question is asked */
    .ask-main.pinned-anim {
        justify-content: flex-start;
        align-items: center;
        padding-top: 32px;
        transition: padding-top 0.7s cubic-bezier(0.23, 1, 0.32, 1);
    }
    .ask-header.pinned-anim {
        margin-top: 0 !important;
        box-shadow: 0 4px 24px rgba(204,188,252,0.13);
        background: var(--bg-secondary);
        top: 0;
        position: sticky;
        z-index: 3;
        transition: box-shadow 0.4s, background 0.4s, top 0.7s cubic-bezier(0.23, 1, 0.32, 1);
    }
    .response-area.visible-anim {
        opacity: 1;
        height: 69vh;
        margin-top: 32px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition: opacity 0.7s cubic-bezier(0.23, 1, 0.32, 1);
    }
    @media (max-width: 600px) {
        .ask-main.pinned-anim {
            padding-top: 12px;
        }
        .response-area.visible-anim {
            height: 75vh;
        }
    }
    </style>
</head>
<body>
    <div class="background-animation" id="backgroundAnimation"></div>
    <script>
    // Prevent bfcache and force reload if page is restored from cache
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister();
            }
        });
    }
    window.addEventListener('pageshow', function(event) {
        if (event.persisted) {
            window.location.reload();
        }
    });
    </script>
    <div class="ask-main">
        <div class="ask-title" id="askTitle">Ask Rabbit Wine</div>
        <div class="ask-subtitle" id="askSubtitle">Ask anything and get a response. Powered by the same style as the main menu.</div>
        <header class="ask-header">
            <form class="ask-row" autocomplete="off" onsubmit="return false;">
                <textarea id="askInput" placeholder="Ask anything..." maxlength="500" autofocus rows="1" style="resize:none;overflow:hidden;"></textarea>
                <button type="button" id="askBtn" aria-label="Ask" title="Ask">ðŸ’¬</button>
            </form>
        </header>
        <main style="width:100%;">
            <div class="response-area" id="responseArea">
                <div class="spinner" id="responseSpinner" style="display:none;">
                    <div class="spin-circle"></div>
                </div>
                <div class="response-content" id="responseContent" style="display:none;"></div>
            </div>
        </main>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="../stars.js"></script>
    <style>
    .spinner {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 80px;
        width: 100%;
        opacity: 1;
        transition: opacity 0.3s;
    }
    .spin-circle {
        border: 4px solid #d1c3f7;
        border-top: 4px solid #7e5fff;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    /* The .response-content class is now styled in ask.css for lighter, smaller text and wider newlines. No direct HTML change needed. */
    .response-content {
        opacity: 0;
        transition: opacity 0.5s;
        min-height: 40px;
        max-height: 100%;
        /* Remove height: auto; */
        overflow-y: auto;
        overscroll-behavior: contain;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE 10+ */
    }
    .response-content::-webkit-scrollbar {
        display: none;
    }
    .response-content.visible {
        opacity: 1;
    }
    </style>
    <script>
    // Randomize ask title and subtitle
    document.addEventListener('DOMContentLoaded', () => {
        const subtitles = [
            "What could go wrong?",
            "Tiny critters on champagne",
            "The journey, not the destination",
            "Nobody jumps around",
            "6.9% Alcohol contents",
            "Heat gets created somewhere else",
            "Bleh",
            "Attempt to obtain an answer",
            "Wish for something odd",
            "Lower your expectations",
            "It will get foggy anyway",
            "This is what you deserve",
            "Bad answer generator",
            "Let me think about that one"
        ];
        const titles = [
            "Hey. You can ask if you want.",
            "I guess I'm here.",
            "Whatever. Type something.",
            "You probably won't like the answer.",
            "Just ask. Or don't.",
            "I'm not really in the mood.",
            "Go ahead. It's fine.",
            "I can't promise much.",
            "You again?",
            "Let's just get this over with.",
            "I don't know. Maybe try asking?",
            "It's not like I have plans.",
            "You can type. I can answer. That's it.",
            "Lower your hopes, please.",
            "I'm not sure why I'm here.",
            "You want something?",
            "I guess I'll try.",
            "Don't expect too much.",
            "Hi. Or whatever.",
            "I could be sleeping instead.",
            "Just type. I'll do my best, I guess.",
            "I mean, you can ask. No promises.",
            "Let's pretend this matters.",
            "I'm not really feeling it today.",
            "You can ask. I'll answer. Maybe."
        ];
        document.getElementById('askTitle').textContent = titles[Math.floor(Math.random() * titles.length)];
        document.getElementById('askSubtitle').textContent = subtitles[Math.floor(Math.random() * subtitles.length)];

        // Animate UI after asking a question
        function pinAskUI() {
            // 1. Fade out title/subtitle
            const titleEl = document.getElementById('askTitle');
            const subtitleEl = document.getElementById('askSubtitle');
            if (titleEl) titleEl.classList.add('hide');
            if (subtitleEl) subtitleEl.classList.add('hide');
            // 2. After fade-out, measure ask-main position, remove titles, and animate
            setTimeout(() => {
                const askMain = document.querySelector('.ask-main');
                const askHeader = document.querySelector('.ask-header');
                // Get current top position of askMain relative to viewport
                const rect = askMain.getBoundingClientRect();
                const startY = rect.top;
                // Remove title/subtitle from DOM
                if (titleEl) titleEl.remove();
                if (subtitleEl) subtitleEl.remove();
                // Force reflow
                void askMain.offsetWidth;
                // Get new top position after removal
                const newRect = askMain.getBoundingClientRect();
                const endY = newRect.top;
                // Set transform to offset the visual jump
                const deltaY = startY - endY;
                askMain.style.transform = `translateY(${deltaY}px)`;
                // Animate to new position
                requestAnimationFrame(() => {
                    askMain.style.transition = 'transform 0.7s cubic-bezier(0.23, 1, 0.32, 1)';
                    askMain.style.transform = '';
                    askMain.classList.add('pinned-anim');
                    askHeader.classList.add('pinned-anim');
                    // After animation, clean up inline style and show response area
                    setTimeout(() => {
                        askMain.style.transition = '';
                        askMain.style.transform = '';
                        const resp = document.getElementById('responseArea');
                        resp.classList.add('visible-anim');
                        resp.style.display = 'block';
                    }, 700);
                });
            }, 350); // match CSS fade
        }
        // Function to stream text into the response box
        function streamResponseText(question, answer, onFirstText) {
            const responseContent = document.getElementById('responseContent');
            responseContent.innerHTML = '<b>IN:</b> ' + $('<div>').text(question).html() + '<br><b>A:</b> ';
            let idx = 0;
            let firstText = true;
            let rendered = '';
            function streamNext() {
                if (idx < answer.length) {
                    rendered += answer[idx];
                    // Replace newlines with <br> for display
                    responseContent.innerHTML = '<b>OUT:</b> ' + $('<div>').text(question).html() + '<br><b>A:</b> ' + rendered.replace(/\n/g, '<br>');
                    responseContent.scrollTop = responseContent.scrollHeight;
                    if (firstText) {
                        firstText = false;
                        if (typeof onFirstText === 'function') onFirstText();
                    }
                    idx++;
                    setTimeout(streamNext, 9 + Math.random() * 15); // 50% faster
                }
            }
            streamNext();
        }

        // Global typestream function for console testing
        (function() {
            let typestreamStarted = false;
            let typestreamQueue = [];
            let typestreamStreaming = false;
            window.typestream = function(part) {
                const spinner = document.getElementById('responseSpinner');
                const responseContent = document.getElementById('responseContent');
                if (!typestreamStarted) {
                    typestreamStarted = true;
                    spinner.style.opacity = '0';
                    setTimeout(() => { spinner.style.display = 'none'; }, 300);
                    responseContent.style.display = 'block';
                    setTimeout(() => {
                        responseContent.classList.add('visible');
                        // Fire custom event
                        const event = new Event('responseBoxVisible');
                        responseContent.dispatchEvent(event);
                    }, 10);
                }
                // If first call, initialize if empty
                if (!responseContent.innerHTML) {
                    responseContent.innerHTML = '';
                }
                // Add part to queue and start streaming if not already
                typestreamQueue.push(part);
                if (!typestreamStreaming) {
                    typestreamStreaming = true;
                    function streamNextChar() {
                        if (typestreamQueue.length === 0) {
                            typestreamStreaming = false;
                            return;
                        }
                        let current = typestreamQueue[0];
                        if (current.length === 0) {
                            typestreamQueue.shift();
                            streamNextChar();
                            return;
                        }
                        let char = current[0];
                        // Convert newlines to <br> tags for proper display
                        if (char === '\n') {
                            responseContent.innerHTML += '<br>';
                        } else {
                            responseContent.innerHTML += char;
                        }
                        responseContent.scrollTop = responseContent.scrollHeight;
                        typestreamQueue[0] = current.slice(1);
                        setTimeout(streamNextChar, 9 + Math.random() * 15); // 50% faster
                    }
                    streamNextChar();
                }
            };
            // For testing: reset typestream state (optional)
            window.typestreamReset = function() {
                typestreamStarted = false;
                typestreamQueue = [];
                typestreamStreaming = false;
                const responseContent = document.getElementById('responseContent');
                responseContent.innerHTML = '';
                responseContent.classList.remove('visible');
                responseContent.style.display = 'none';
                const spinner = document.getElementById('responseSpinner');
                spinner.style.display = 'flex';
                spinner.style.opacity = '1';
            };
        })();

        // Patch the askBtn click to trigger animation and response
        $('#askBtn').off('click').on('click', function() {
            // Abort previous fetch/session if any
            if (window.askAbortController) {
                window.askAbortController.abort();
            }
            window.askAbortController = new AbortController();
            const abortSignal = window.askAbortController.signal;

            const $input = $('#askInput');
            const question = $input.val().trim();
            if (!question) return;
            pinAskUI();
            $input.val('');
            $input.height('auto');
            // Hide response content, show spinner
            const responseArea = document.getElementById('responseArea');
            const spinner = document.getElementById('responseSpinner');
            const responseContent = document.getElementById('responseContent');
            spinner.style.display = 'flex';
            spinner.style.opacity = '1';
            responseContent.style.display = 'none';
            responseContent.classList.remove('visible');

            // --- Call backend webservice and stream output ---
            window.typestreamReset && window.typestreamReset();
            const guid = '00000000-0000-0000-0000-000000000000';
            
            // Try HTTPS first, fallback to direct IP or alternative approaches
            const baseUrl = 'https://rabbitwine.redscientist.com:6969';
            const askUrl = baseUrl + '/ask';
            const testUrl = baseUrl + '/test';
            
            let receivedAny = false;
            let questionHtml = '<b>IN:</b> ' + $('<div>').text(question).html() + '<br><b>OUT:</b> ';
            responseContent.innerHTML = questionHtml;
            responseContent.scrollTop = responseContent.scrollHeight;
            
            // First, test connectivity with a simple GET request
            console.log('Testing connectivity to:', testUrl);
            fetch(testUrl, { 
                method: 'GET',
                signal: abortSignal,
                // Don't follow redirects to catch certificate issues
                redirect: 'manual'
            }).then(testResp => {
                console.log('Test response status:', testResp.status);
                // If test works, proceed with the actual request
                return makeAskRequest();
            }).catch(testErr => {
                console.error('Connectivity test failed:', testErr);
                window.typestream && window.typestream("[Connection test failed: " + testErr.message + "]\n");
                window.typestream && window.typestream("[This usually means:\n");
                window.typestream && window.typestream("1. The server is not running\n");
                window.typestream && window.typestream("2. Firewall is blocking the connection\n"); 
                window.typestream && window.typestream("3. SSL certificate issues (try visiting " + baseUrl + "/test directly first)\n");
                window.typestream && window.typestream("4. DNS resolution problems\n]\n");
            });
            
            function makeAskRequest() {
                // Use Fetch API with ReadableStream for SSE
                return fetch(askUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ guid: guid, prompt: question }),
                    signal: abortSignal
                }).then(resp => {
                    console.log('Ask response status:', resp.status);
                    if (!resp.ok) {
                        throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                    }
                    if (!resp.body) throw new Error('No response body');
                    const reader = resp.body.getReader();
                    let decoder = new TextDecoder();
                    let buffer = '';
                    function processBuffer() {
                        let idx;
                        while ((idx = buffer.indexOf('\n\n')) !== -1) {
                            let chunk = buffer.slice(0, idx);
                            buffer = buffer.slice(idx + 2);
                            if (chunk.startsWith('data: ')) {
                                let line = chunk.slice(6);
                                // Stream each character
                                for (let c of line + '\n') {
                                    window.typestream && window.typestream(c);
                                }
                                receivedAny = true;
                            }
                        }
                    }
                    function read() {
                        reader.read().then(({ done, value }) => {
                            if (done) {
                                if (!receivedAny) {
                                    window.typestream && window.typestream("[No response received from backend]\n");
                                }
                                return;
                            }
                            buffer += decoder.decode(value, { stream: true });
                            processBuffer();
                            read();
                        }).catch(err => {
                            if (abortSignal.aborted) {
                                window.typestream && window.typestream("[Request cancelled, waiting for new answer stream]\n");
                            } else {
                                window.typestream && window.typestream("[Streaming error: " + err.message + "]\n");
                            }
                        });
                    }
                    read();
                }).catch(err => {
                    if (abortSignal.aborted) {
                        window.typestream && window.typestream("[Request cancelled, waiting for new answer stream]\n");
                    } else {
                        window.typestream && window.typestream("[Request error: " + err.message + "]\n");
                        window.typestream && window.typestream("[Try visiting " + baseUrl + "/test in a new tab to check server status]\n");
                    }
                });
            }
        });
    });
    // Auto-grow textarea
    $('#askInput').on('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });
    // Enter to ask (but not shift+enter)
    $('#askInput').on('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            $('#askBtn').click();
        }
    });
    </script>
</body>
</html>

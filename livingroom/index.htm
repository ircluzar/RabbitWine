<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Rabbit Wine Livingroom</title>
	<link rel="preconnect" href="https://fonts.googleapis.com" />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
	<link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;500;600&display=swap" rel="stylesheet" />
	<style>
		:root {
			--bg: #0c0d10;
			--panel: rgba(17, 19, 26, 0.9);
			--panel-border: rgba(255, 255, 255, 0.08);
			--accent: #f5c451;
			--text: #f7f7f2;
			--muted: #9aa0ad;
			--shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
			--global-zoom: 1;
		}

		* {
			box-sizing: border-box;
		}

		html, body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			background: radial-gradient(circle at 20% 20%, rgba(245, 196, 81, 0.08), transparent 35%),
				radial-gradient(circle at 80% 10%, rgba(147, 227, 255, 0.08), transparent 35%),
				var(--bg);
			color: var(--text);
			font-family: "Sora", system-ui, -apple-system, sans-serif;
			overflow: hidden;
		}

		body {
			display: grid;
			place-items: center;
		}

		#app {
			position: relative;
			width: 100%;
			height: 100%;
		}

		#menuToggle {
			position: fixed;
			top: 16px;
			left: 16px;
			z-index: 2000;
			width: 48px;
			height: 48px;
			border-radius: 14px;
			border: 1px solid var(--panel-border);
			background: var(--panel);
			color: var(--text);
			font-size: 24px;
			cursor: pointer;
			box-shadow: var(--shadow);
			display: grid;
			place-items: center;
			transition: transform 0.15s ease, background 0.2s ease;
		}

		#menuToggle:hover {
			transform: translateY(-2px);
			background: rgba(255, 255, 255, 0.06);
		}

		#viewport {
			position: relative;
			width: 100vw;
			height: 100vh;
			padding: clamp(12px, 2vw, 24px);
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
			touch-action: none;
		}

		body.fullscreen-active {
			overflow: hidden;
			overflow-anchor: none;
		}

		body.fullscreen-active #viewport {
			padding: 0;
		}

		body.fullscreen-active #stageFrame {
			border-radius: 0;
			max-width: none;
			max-height: none;
		}

		#stageFrame {
			position: relative;
			width: min(92vw, 1800px);
			aspect-ratio: 16 / 9;
			max-height: calc(100vh - 96px);
			margin: 0 auto;
			flex-shrink: 0;
			will-change: transform;
			border-radius: 18px;
			background: linear-gradient(135deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
			border: 1px solid var(--panel-border);
			overflow: hidden;
			box-shadow: var(--shadow);
		}

		#webcamFxCanvas {
			position: absolute;
			inset: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			z-index: 50;
			mix-blend-mode: normal;
		}

		#stageScroller {
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		#stage {
			position: relative;
			width: 100%;
			height: 100%;
			background: radial-gradient(circle at 40% 40%, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0)),
				radial-gradient(circle at 70% 60%, rgba(57, 140, 255, 0.12), rgba(57, 140, 255, 0));
			overflow: hidden;
			transform-origin: center center;
			transform: scale(var(--global-zoom));
			cursor: grab;
			touch-action: pinch-zoom pan-x pan-y;
		}

		#stage.dragging {
			cursor: grabbing;
		}

		#objectLayer {
			position: absolute;
			inset: 0;
		}

		.object {
			position: absolute;
			transform: translate(-50%, -50%) scale(1);
			transform-origin: center center;
			user-select: none;
			touch-action: none;
			will-change: transform, top, left;
			border-radius: 6px;
			cursor: grab;
		}

		.object.locked {
			cursor: default;
			pointer-events: none;
		}

		.object.base {
			cursor: default;
		}

		.object.base {
			inset: 0;
			width: 100%;
			height: 100%;
			transform: none;
			pointer-events: none;
		}

		.object img,
		.object video {
			display: block;
			max-width: 320px;
			max-height: 320px;
			border-radius: 6px;
			pointer-events: none;
		}

		.object.base img,
		.object.base video {
			width: 100%;
			height: 100%;
			object-fit: cover;
			max-width: none;
			max-height: none;
			box-shadow: none;
		}

		.shadow {
			position: absolute;
			left: calc(50% + var(--shadow-offset-x, 0px));
			top: calc(100% + var(--shadow-offset-y, 0px));
			transform: translate(-50%, -50%);
			pointer-events: none;
			border-radius: 999px;
			filter: blur(4px);
			background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.45) 0%, rgba(0, 0, 0, 0) 70%);
			opacity: var(--shadow-opacity, 0.45);
			width: var(--shadow-size, 220px);
			height: calc(var(--shadow-size, 220px) * 0.55);
		}

		#hud {
			position: absolute;
			bottom: 16px;
			right: 16px;
			z-index: 1500;
			display: grid;
			gap: 8px;
			grid-template-columns: 1fr;
			padding: 10px 12px;
			background: var(--panel);
			border: 1px solid var(--panel-border);
			border-radius: 12px;
			box-shadow: var(--shadow);
			max-width: 320px;
		}

		#hudHeader {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
		}

		#hudControls {
			display: flex;
			gap: 10px;
			align-items: center;
			flex-wrap: wrap;
		}

		#hud.collapsed #hudControls {
			display: none;
		}

		#zoomValue {
			color: var(--muted);
			font-size: 12px;
			width: 72px;
		}

		input[type="range"] {
			width: 160px;
			accent-color: var(--accent);
		}

		#welcomeOverlay {
			position: fixed;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			background: rgba(0, 0, 0, 0.1);
			z-index: 3500;
			padding: 20px;
		}

		#welcomeCard {
			position: relative;
			background: var(--panel);
			border: 1px solid var(--panel-border);
			border-radius: 16px;
			padding: 24px;
			box-shadow: var(--shadow);
			max-width: min(560px, 92vw);
			text-align: center;
			display: grid;
			gap: 12px;
			justify-items: center;
		}

		#welcomeCard img {
			width: 120px;
			height: auto;
			filter: drop-shadow(0 6px 20px rgba(0,0,0,0.35));
		}

		#welcomeCard h2 {
			margin: 0;
			font-size: 22px;
		}

		#welcomeCard p {
			margin: 0;
			color: var(--muted);
			line-height: 1.5;
		}

		#modalOverlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.55);
			display: none;
			z-index: 3000;
			align-items: flex-start;
			justify-content: center;
			padding-top: 72px;
			overflow-y: auto;
		}

		#modal {
			background: var(--panel);
			border: 1px solid var(--panel-border);
			border-radius: 14px;
			width: min(720px, 92vw);
			padding: 20px;
			box-shadow: var(--shadow);
		}

		#modal h2 {
			margin: 0 0 12px;
			font-size: 20px;
		}

		.row {
			display: flex;
			gap: 10px;
			margin-bottom: 12px;
			flex-wrap: wrap;
		}

		.row label {
			font-size: 13px;
			color: var(--muted);
		}

		.inlineLabel {
			font-size: 13px;
			color: var(--muted);
			min-width: 64px;
		}

		input[type="text"],
		input[type="file"],
		button,
		select {
			background: rgba(255, 255, 255, 0.06);
			border: 1px solid var(--panel-border);
			color: var(--text);
			border-radius: 10px;
			padding: 10px 12px;
			font-size: 14px;
		}

		button {
			cursor: pointer;
			transition: transform 0.12s ease, background 0.2s ease;
		}

		button:hover {
			background: rgba(255, 255, 255, 0.12);
			transform: translateY(-1px);
		}

		button:active {
			transform: translateY(0);
		}

		#objectList {
			display: grid;
			gap: 8px;
		}

		.card {
			border: 1px solid var(--panel-border);
			border-radius: 10px;
			padding: 10px;
			background: rgba(255, 255, 255, 0.04);
			display: grid;
			gap: 10px;
			grid-template-columns: 1fr;
		}

		.card.collapsed .cardDetails {
			display: none;
		}

		.cardHeaderTitle {
			font-weight: 600;
			font-size: 14px;
			color: var(--text);
		}

		.controlRow {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			align-items: center;
		}

		.controlRow > * {
			flex: 1 1 auto;
			min-width: 120px;
		}

		.controlRow.compact > * {
			min-width: 80px;
			flex: 0 0 auto;
		}

		.card .meta {
			display: grid;
			gap: 6px;
		}

		.badge {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			background: rgba(255, 255, 255, 0.08);
			border-radius: 999px;
			padding: 4px 10px;
			font-size: 12px;
			color: var(--muted);
		}

		.iconBtn {
			width: 36px;
			height: 36px;
			display: grid;
			place-items: center;
			border-radius: 10px;
			border: 1px solid var(--panel-border);
			background: rgba(255, 255, 255, 0.06);
			font-size: 16px;
			color: var(--text);
		}

		.miniIconBtn {
			width: 28px;
			height: 28px;
			border-radius: 8px;
			font-size: 13px;
			padding: 0;
		}

		.iconLabelBtn {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			gap: 6px;
			width: auto;
			min-width: 36px;
			height: 36px;
			padding: 0 10px;
		}

		.btnLabel {
			font-size: 12px;
			color: var(--text);
			opacity: 0.9;
		}

		.listActions {
			display: flex;
			gap: 6px;
		}

		.pillActions {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
		}

		.hidden {
			display: none !important;
		}

		#dropHint {
			position: absolute;
			inset: 12px;
			border: 1px dashed rgba(255, 255, 255, 0.12);
			border-radius: 14px;
			display: grid;
			place-items: center;
			color: var(--muted);
			pointer-events: none;
			font-size: 14px;
			opacity: 0.5;
		}

		@media (max-width: 820px) and (orientation: portrait) {
			html, body {
				overflow: auto;
			}

			#viewport {
				overflow-x: auto;
				overflow-y: auto;
				touch-action: pan-x pinch-zoom;
				padding: 10px;
			}

			#stageFrame {
				width: 140vw;
				height: 100vh;
				max-height: none;
				aspect-ratio: 16 / 9;
			}

			#hud {
				bottom: auto;
				top: 12px;
				max-width: calc(100vw - 24px);
				width: auto;
				left: 12px;
				right: 12px;
			}

			#hudControls {
				flex-direction: column;
				align-items: stretch;
			}
		}

		@media (max-width: 820px) and (orientation: landscape) {
			html, body {
				overflow: hidden;
			}

			#viewport {
				overflow: hidden;
				padding: 10px;
			}

			#hud {
				top: 12px;
				bottom: auto;
				max-width: 260px;
				left: 12px;
				right: 12px;
			}

			#hudControls {
				flex-wrap: wrap;
				gap: 6px;
			}
		}

		@media (max-width: 820px) and (orientation: portrait) {
			#viewport {
				justify-content: flex-start;
				align-items: flex-start;
			}

			#stageFrame {
				margin: 0;
			}
		}

		.warp-handle {
			position: absolute;
			width: 16px;
			height: 16px;
			background: var(--accent);
			border: 2px solid #fff;
			border-radius: 50%;
			transform: translate(-50%, -50%);
			cursor: crosshair;
			z-index: 100;
			box-shadow: 0 2px 4px rgba(0,0,0,0.5);
			display: none;
		}
		.object.warping .warp-handle {
			display: block;
		}
	</style>
</head>
<body>
	<div id="app">
		<button id="menuToggle" aria-label="Open menu">â˜°</button>

		<div id="viewport">
			<div id="stageFrame">
				<div id="stageScroller">
					<div id="stage">
						<div id="objectLayer"></div>
						<div id="dropHint">Drop images or videos anywhere</div>
					</div>
				</div>
				<canvas id="webcamFxCanvas" aria-hidden="true"></canvas>
			</div>
		</div>

		<div id="hud" class="collapsed">
			<div id="hudHeader">
				<div class="badge">Camera Control</div>
				<button id="hudToggle" class="iconBtn" aria-label="Toggle camera controls">â–¸</button>
			</div>
			<div id="hudControls">
				<label for="zoom">Camera Zoom</label>
				<input id="zoom" type="range" min="0.5" max="2.5" step="0.05" value="1" />
				<div id="zoomValue">100%</div>
				<button id="resetView">Reset view</button>
				<button id="fullscreenToggle">Fullscreen</button>
				<button id="webcamFxToggle">Webcam FX: On</button>
			</div>
		</div>

		<div id="welcomeOverlay">
			<div id="welcomeCard">
				<img src="../rabbitwine.png" alt="RabbitWine logo" />
				<h2>Welcome to Rabbit Wine</h2>
				<p id="subtitleText"></p>
			</div>
		</div>

		<div id="modalOverlay">
			<div id="modal">
				<h2>Scene Manager</h2>

				<div class="row">
					<label for="filenameInput">File:</label>
					<input id="filenameInput" type="text" placeholder="filename.ext" aria-label="Filename" />
					<button id="addByName">Add by filename</button>
				</div>

				<div class="row">
					<button id="downloadJson">Download JSON</button>
					<label class="badge">
						<input id="uploadJson" type="file" accept="application/json" />
						Import JSON
					</label>
					<button id="clearScene">Clear scene</button>
				</div>

				<div class="row">
					<button id="unlockAll">Unlock all</button>
					<button id="lockAll">Lock all</button>
				</div>

				<div class="row">
					<label class="badge" style="display:flex;align-items:center;gap:8px;">
						<input id="autoImportToggle" type="checkbox" />
						Auto-import default scene on startup
					</label>
				</div>

				<div class="row">
					<label for="subtitleInput">Scene subtitle:</label>
					<input id="subtitleInput" type="text" placeholder="Subtitle (optional)" aria-label="Subtitle" />
				</div>

				<div class="row">
					<label for="musicInput">Scene music:</label>
					<input id="musicInput" type="text" placeholder="Music filename (optional, defaults to music.mp3)" aria-label="Music filename" />
				</div>

				<div class="row">
					<div class="badge">Objects</div>
				</div>

				<div class="row">
					<input id="objectFilter" type="text" placeholder="Filter by alias or name" aria-label="Filter objects" />
					<button id="clearFilter">Clear</button>
				</div>

				<div id="objectList"></div>
			</div>
		</div>
	</div>

	<script src="../memory.js"></script>
	<script>
		const NAMESPACE = "LivingRoom";
		const STORAGE_KEY = "scene_v1";
		const AUTO_IMPORT_KEY = "auto_import";
		const DEV_UNLOCK_KEY = "dev_unlocked";
		const WEBCAM_FX_KEY = "webcam_fx_enabled";
		const DEFAULT_ASPECT = 16 / 9;
		const DEFAULT_MUSIC = "music.mp3";
		const viewportEl = document.getElementById("viewport");
		const objectLayer = document.getElementById("objectLayer");
		const stage = document.getElementById("stage");
		const stageFrame = document.getElementById("stageFrame");
		const menuToggle = document.getElementById("menuToggle");
		const modalOverlay = document.getElementById("modalOverlay");
		const objectList = document.getElementById("objectList");
		const filenameInput = document.getElementById("filenameInput");
		const subtitleInput = document.getElementById("subtitleInput");
		const musicInput = document.getElementById("musicInput");
		const objectFilter = document.getElementById("objectFilter");
		const clearFilterBtn = document.getElementById("clearFilter");
		const zoomSlider = document.getElementById("zoom");
		const zoomValue = document.getElementById("zoomValue");
		const resetView = document.getElementById("resetView");
		const webcamFxCanvas = document.getElementById("webcamFxCanvas");
		const webcamFxToggle = document.getElementById("webcamFxToggle");
		const downloadJson = document.getElementById("downloadJson");
		const uploadJson = document.getElementById("uploadJson");
		const clearScene = document.getElementById("clearScene");
		const addByName = document.getElementById("addByName");
		const autoImportToggle = document.getElementById("autoImportToggle");
		const lockAllBtn = document.getElementById("lockAll");
		const unlockAllBtn = document.getElementById("unlockAll");
		const dropHint = document.getElementById("dropHint");
		const welcomeOverlay = document.getElementById("welcomeOverlay");
		const welcomeCard = document.getElementById("welcomeCard");
		const subtitleText = document.getElementById("subtitleText");
		const hud = document.getElementById("hud");
		const hudToggle = document.getElementById("hudToggle");
		const hudControls = document.getElementById("hudControls");
		const fullscreenToggle = document.getElementById("fullscreenToggle");

		const EMBED_MODE = new URLSearchParams(window.location.search).get("embed") === "1";
		const music = new Audio("music.mp3");
		music.loop = true;
		music.preload = "auto";
		music.volume = 0;
		const MUSIC_TARGET_VOLUME = 0.33;
		const MUSIC_FADE_MS = 12000;
		let musicFadeRaf = null;
		let externalMusicActive = false;

		let scene = { objects: [], referenceSize: null, subtitle: "", music: "" };
		let dragState = null;
		let panState = null;
		let cameraOffset = { x: 0, y: 0 };
		let currentZoom = 1;
		let resizeRaf = null;
		const webcamFxBuffer = document.createElement("canvas");
		const webcamFxCtx = webcamFxCanvas.getContext("2d");
		const webcamFxBufferCtx = webcamFxBuffer.getContext("2d");
		let webcamFxEnabled = true;
		let webcamFxBusy = false;
		let webcamFxTimer = null;
		let fxIntervalMs = 666; // initial slower interval
		let jpegQuality = 0.1; // initial low quality
		let autoImportEnabled = true;
		let autoImportRun = false;
		let devUnlocked = false;
		let filterTerm = "";
		const collapsedState = new Map();
		const isFullscreenActive = () => !!document.fullscreenElement;

		const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
		const setMusicVolume = (value) => {
			music.volume = clamp(value, 0, MUSIC_TARGET_VOLUME);
		};
		const enforceMusicCeiling = () => {
			if (music.volume > MUSIC_TARGET_VOLUME) {
				setMusicVolume(music.volume);
			}
		};
		const applyDevUnlockState = () => {
			if (!menuToggle) return;
			menuToggle.style.display = devUnlocked ? "grid" : "none";
		};
		const persistDevUnlockState = () => {
			try {
				memory.write(NAMESPACE, DEV_UNLOCK_KEY, devUnlocked);
			} catch (err) {
				console.warn("Unable to persist dev unlock state", err);
			}
		};
		const loadDevUnlockState = () => {
			try {
				devUnlocked = memory.read(NAMESPACE, DEV_UNLOCK_KEY) === true;
			} catch (err) {
				devUnlocked = false;
			}
			applyDevUnlockState();
		};
		const getMusicSource = () => (scene.music && scene.music.trim()) || DEFAULT_MUSIC;
		const setMusicSource = (src) => {
			const next = (src && src.trim()) || DEFAULT_MUSIC;
			if (music.src !== next) {
				music.src = next;
			}
		};
		const setFxQuality = (value) => {
			jpegQuality = clamp(value, 0, 1);
		};
		const setFxInterval = (ms) => {
			const next = Math.max(16, Math.round(ms || 0));
			if (next === fxIntervalMs) return;
			fxIntervalMs = next;
			if (webcamFxEnabled) startWebcamFxLoop();
		};
		const isImage = (name) => /\.(png|jpg|jpeg|webp|gif)$/i.test(name || "");
		const isVideo = (name) => /\.(mp4|webm|mov|m4v)$/i.test(name || "");
		const getBase = () => scene.objects.find((o) => o.base);
		const ensureAlias = (obj) => {
			if (!obj) return;
			const alias = typeof obj.alias === "string" ? obj.alias.trim() : "";
			obj.alias = alias || obj.name || "object";
		};
		const ensureKind = (obj) => {
			if (!obj) return;
			if (obj.kind === "video" || obj.kind === "image") return;
			obj.kind = isVideo(obj.name || "") ? "video" : "image";
		};

		const loadAutoImportPreference = () => {
			const stored = memory.read(NAMESPACE, AUTO_IMPORT_KEY);
			if (stored === undefined) {
				memory.write(NAMESPACE, AUTO_IMPORT_KEY, true);
				return true;
			}
			return stored === true;
		};

		const persistAutoImportPreference = (value) => {
			autoImportEnabled = !!value;
			memory.write(NAMESPACE, AUTO_IMPORT_KEY, autoImportEnabled);
			if (autoImportToggle) autoImportToggle.checked = autoImportEnabled;
		};

		const autoImportDefaultScene = async () => {
			if (!autoImportEnabled || autoImportRun) return;
			autoImportRun = true;
			try {
				const res = await fetch("default.json", { cache: "no-cache" });
				if (!res.ok) throw new Error(`default.json fetch failed: ${res.status}`);
				const text = await res.text();
				if (text) {
					scene.objects = [];
					importScene(text);
				}
			} catch (err) {
				console.warn("Auto-import default scene failed", err);
			}
		};

		const createNoisePattern = () => {
			const noiseCanvas = document.createElement("canvas");
			const size = 64;
			noiseCanvas.width = size;
			noiseCanvas.height = size;
			const ctx = noiseCanvas.getContext("2d");
			const imageData = ctx.createImageData(size, size);
			for (let i = 0; i < imageData.data.length; i += 4) {
				const val = Math.floor(Math.random() * 255);
				imageData.data[i] = val;
				imageData.data[i + 1] = val;
				imageData.data[i + 2] = val;
				imageData.data[i + 3] = 69; // subtle alpha
			}
			ctx.putImageData(imageData, 0, 0);
			return webcamFxBufferCtx.createPattern(noiseCanvas, "repeat");
		};

		const syncWebcamFxSize = () => {
			const rect = stageFrame.getBoundingClientRect();
			const width = Math.max(2, Math.round(rect.width));
			const height = Math.max(2, Math.round(rect.height));
			if (webcamFxCanvas.width !== width || webcamFxCanvas.height !== height) {
				webcamFxCanvas.width = width;
				webcamFxCanvas.height = height;
			}
			if (webcamFxBuffer.width !== width || webcamFxBuffer.height !== height) {
				webcamFxBuffer.width = width;
				webcamFxBuffer.height = height;
			}
		};

		const coverDimensions = (srcW, srcH, destW, destH) => {
			const srcAspect = srcW / srcH;
			const destAspect = destW / destH;
			let w = destW;
			let h = destH;
			if (srcAspect > destAspect) {
				h = destH;
				w = destH * srcAspect;
			} else {
				w = destW;
				h = destW / srcAspect;
			}
			return {
				x: (destW - w) / 2,
				y: (destH - h) / 2,
				w,
				h,
			};
		};

		const drawSceneIntoBuffer = () => {
			const { sx, sy, uni } = getScaleFactors();
			const ordered = [...scene.objects].sort((a, b) => a.z - b.z);
			webcamFxBufferCtx.clearRect(0, 0, webcamFxBuffer.width, webcamFxBuffer.height);
			for (const obj of ordered) {
				if (obj.hidden) continue;
				const wrapper = objectLayer.querySelector(`[data-id="${obj.id}"]`);
				const media = wrapper?.querySelector("img, video");
				if (!media) continue;
				let mediaW = media.videoWidth || media.naturalWidth || media.clientWidth || 320;
				let mediaH = media.videoHeight || media.naturalHeight || media.clientHeight || 240;
				if (!mediaW || !mediaH) continue;
				if (!obj.base) {
					const clampFactor = Math.min(1, 320 / mediaW, 320 / mediaH);
					mediaW *= clampFactor;
					mediaH *= clampFactor;
				}
				if (obj.base) {
					const dims = coverDimensions(mediaW, mediaH, webcamFxBuffer.width, webcamFxBuffer.height);
					webcamFxBufferCtx.drawImage(media, dims.x, dims.y, dims.w, dims.h);
					continue;
				}
				const scale = (obj.scale ?? 1) * uni;
				const drawW = mediaW * scale;
				const drawH = mediaH * scale;
				const dx = (obj.x ?? 0) * sx - drawW / 2;
				const dy = (obj.y ?? 0) * sy - drawH / 2;

				if (obj.shadowEnabled) {
					const size = (obj.shadowSize ?? 220) * uni * (obj.scale ?? 1);
					const shadowH = size * 0.55;
					const cx = dx + drawW / 2 + (obj.shadowOffsetX ?? 0) * sx;
					const cy = dy + drawH + (obj.shadowOffsetY ?? 0) * sy + (shadowH / 2) -35; // midpoint between previous placements
					const peakAlpha = (obj.shadowOpacity ?? 0.45) * 0.45; // CSS gradient 0.45 peak * opacity
					webcamFxBufferCtx.save();
					webcamFxBufferCtx.translate(cx, cy);
					webcamFxBufferCtx.scale(size / 2, shadowH / 2);
					webcamFxBufferCtx.filter = "blur(4px)";
					const g = webcamFxBufferCtx.createRadialGradient(0, 0, 0, 0, 0, 1);
					g.addColorStop(0, `rgba(0, 0, 0, ${peakAlpha})`);
					g.addColorStop(0.7, "rgba(0, 0, 0, 0)");
					webcamFxBufferCtx.fillStyle = g;
					webcamFxBufferCtx.beginPath();
					webcamFxBufferCtx.rect(-1, -1, 2, 2);
					webcamFxBufferCtx.fill();
					webcamFxBufferCtx.restore();
				}
				webcamFxBufferCtx.drawImage(media, dx, dy, drawW, drawH);
			}
		};

		const applyNoiseOverlay = () => {
			const noise = createNoisePattern();
			webcamFxBufferCtx.save();
			webcamFxBufferCtx.globalAlpha = 0.24;
			webcamFxBufferCtx.fillStyle = noise;
			webcamFxBufferCtx.fillRect(0, 0, webcamFxBuffer.width, webcamFxBuffer.height);
			webcamFxBufferCtx.restore();
		};

		const renderWebcamFxFrame = () => {
			const hasVideo = scene.objects.some(o => !o.hidden && o.kind === "video");
			if (!webcamFxEnabled || webcamFxBusy || hasVideo) return;
			webcamFxBusy = true;
			try {
				syncWebcamFxSize();
				drawSceneIntoBuffer();
				applyNoiseOverlay();
				webcamFxBuffer.toBlob((blob) => {
					if (!blob) {
						webcamFxBusy = false;
						setWebcamFxEnabled(false);
						return;
					}
					createImageBitmap(blob)
						.then((bitmap) => {
							webcamFxCtx.clearRect(0, 0, webcamFxCanvas.width, webcamFxCanvas.height);
							webcamFxCtx.drawImage(bitmap, 0, 0, webcamFxCanvas.width, webcamFxCanvas.height);
						})
						.catch((err) => {
							console.warn("Webcam FX bitmap failed", err);
							setWebcamFxEnabled(false);
						})
						.finally(() => {
							webcamFxBusy = false;
						});
				}, "image/jpeg", jpegQuality);
			} catch (err) {
				console.warn("Webcam FX failed", err);
				webcamFxBusy = false;
				setWebcamFxEnabled(false);
			}
		};

		const startWebcamFxLoop = () => {
			if (webcamFxTimer) clearInterval(webcamFxTimer);
			if (!webcamFxEnabled) return;
			const hasVideo = scene.objects.some(o => !o.hidden && o.kind === "video");
			if (hasVideo) return;
			webcamFxCanvas.classList.remove("hidden");
			webcamFxTimer = setInterval(renderWebcamFxFrame, fxIntervalMs);
			renderWebcamFxFrame();
		};

		const stopWebcamFxLoop = () => {
			if (webcamFxTimer) clearInterval(webcamFxTimer);
			webcamFxTimer = null;
			webcamFxCtx.clearRect(0, 0, webcamFxCanvas.width, webcamFxCanvas.height);
			webcamFxCanvas.classList.add("hidden");
		};

		const setWebcamFxEnabled = (enabled, { persist = true } = {}) => {
			webcamFxEnabled = enabled;
			if (persist) {
				try {
					memory.write(NAMESPACE, WEBCAM_FX_KEY, enabled);
				} catch (err) {
					console.warn("Unable to persist webcam FX state", err);
				}
			}
			if (webcamFxToggle) {
				webcamFxToggle.textContent = `Webcam FX: ${enabled ? "On" : "Off"}`;
			}
			if (enabled) {
				startWebcamFxLoop();
			} else {
				stopWebcamFxLoop();
			}
		};

		const loadWebcamFxState = () => {
			try {
			const stored = memory.read(NAMESPACE, WEBCAM_FX_KEY);
			if (stored === undefined) {
				webcamFxEnabled = true; // default true
				return;
			}
			webcamFxEnabled = stored === true;
		} catch (err) {
			webcamFxEnabled = true;
		}
	};

const requestFullscreen = async () => {
	if (!viewportEl.requestFullscreen) return;
	try {
		await viewportEl.requestFullscreen();
	} catch (err) {
		console.warn("Fullscreen request failed", err);
	}
};

const exitFullscreen = async () => {
	if (!document.exitFullscreen || !isFullscreenActive()) return;
	try {
		await document.exitFullscreen();
	} catch (err) {
		console.warn("Exit fullscreen failed", err);
	}
};

const toggleFullscreen = () => {
	if (isFullscreenActive()) {
		exitFullscreen();
	} else {
		requestFullscreen();
	}
};

const setupWebcamFxRamp = () => {
	setFxQuality(0.1);
	setFxInterval(666);
	const start = performance.now();
	const phase1End = 2500;
	const phase2End = 5000;
	const step = () => {
		const elapsed = performance.now() - start;
		if (elapsed <= phase1End) {
			const p = clamp(elapsed / phase1End, 0, 1);
			setFxQuality(0.1 + (0.1 * p));
			requestAnimationFrame(step);
			return;
		}
		if (elapsed <= phase2End) {
			setFxInterval(420);
			const p = clamp((elapsed - phase1End) / (phase2End - phase1End), 0, 1);
			setFxQuality(0.2 + (0.1 * p));
			requestAnimationFrame(step);
			return;
		}
		setFxInterval(420);
		setFxQuality(0.3);
	};
	requestAnimationFrame(step);
};
		const fadeInMusic = () => {
			if (musicFadeRaf) cancelAnimationFrame(musicFadeRaf);
			const start = performance.now();
			setMusicVolume(0);
			const step = (now) => {
				const progress = clamp((now - start) / MUSIC_FADE_MS, 0, 1);
				setMusicVolume(MUSIC_TARGET_VOLUME * progress);
				if (progress < 1) {
					musicFadeRaf = requestAnimationFrame(step);
				}
			};
			musicFadeRaf = requestAnimationFrame(step);
		};

		const fadeOutAndStopMusic = (durationMs = 1200) => {
			if (musicFadeRaf) cancelAnimationFrame(musicFadeRaf);
			const start = performance.now();
			const initialVolume = music.volume;
			const step = (now) => {
				const progress = clamp((now - start) / durationMs, 0, 1);
				setMusicVolume(initialVolume * (1 - progress));
				if (progress < 1) {
					musicFadeRaf = requestAnimationFrame(step);
				} else {
					try {
						music.pause();
						music.currentTime = 0;
					} catch (err) {}
				}
			};
			musicFadeRaf = requestAnimationFrame(step);
		};

		const startMusic = () => {
			if (EMBED_MODE && externalMusicActive) return;
			setMusicVolume(0);
			setMusicSource(getMusicSource());
			const attemptPlay = () => {
				music
					.play()
					.then(() => {
						fadeInMusic();
					})
					.catch(() => {
						const resume = () => {
							music.play().then(() => fadeInMusic()).catch(() => {});
							document.body.removeEventListener("pointerdown", resume);
						};
						document.body.addEventListener("pointerdown", resume, { once: true });
					});
			};
			attemptPlay();
		};

		const loadScene = () => {
			try {
				const data = memory.read(NAMESPACE, STORAGE_KEY);
				if (!data) return;
				if (Array.isArray(data.objects)) {
					scene.objects = data.objects;
					scene.objects.forEach((o) => {
						ensureAlias(o);
						ensureKind(o);
					});
				}
				if (data.referenceSize && data.referenceSize.w && data.referenceSize.h) {
					scene.referenceSize = data.referenceSize;
				}
				scene.subtitle = typeof data.subtitle === "string" ? data.subtitle : "";
				scene.music = typeof data.music === "string" ? data.music : "";
			} catch (err) {
				console.error("Failed to load scene", err);
			}
		};

		const persistScene = () => {
			try {
				memory.write(NAMESPACE, STORAGE_KEY, scene);
			} catch (err) {
				console.error("Failed to save scene", err);
			}
		};

		const renderSubtitle = () => {
			if (!subtitleText) return;
			const value = (scene.subtitle || "").trim();
			subtitleText.textContent = value;
			subtitleText.style.display = value ? "block" : "none";
		};

		const nextId = () => crypto.randomUUID();

		const getReferenceSize = () => {
			if (scene.referenceSize && scene.referenceSize.w && scene.referenceSize.h) return scene.referenceSize;
			const rect = stageFrame.getBoundingClientRect();
			const ref = { w: rect.width || 1, h: rect.height || 1 };
			scene.referenceSize = ref;
			persistScene();
			return ref;
		};

		const centerCoords = () => {
			const ref = getReferenceSize();
			return { x: ref.w / 2, y: ref.h / 2 };
		};

		const getScaleFactors = () => {
			const rect = stageFrame.getBoundingClientRect();
			const ref = getReferenceSize();
			const sx = rect.width / ref.w;
			const sy = rect.height / ref.h;
			return { sx, sy, uni: Math.min(sx, sy), rect, ref };
		};

		const hasViewportOverflow = () => {
			const rect = stageFrame.getBoundingClientRect();
			const viewportRect = viewportEl.getBoundingClientRect();
			const styles = getComputedStyle(viewportEl);
			const padX = (parseFloat(styles.paddingLeft) || 0) + (parseFloat(styles.paddingRight) || 0);
			const padY = (parseFloat(styles.paddingTop) || 0) + (parseFloat(styles.paddingBottom) || 0);
			const contentW = Math.max(1, viewportRect.width - padX);
			const contentH = Math.max(1, viewportRect.height - padY);
			return rect.width > contentW + 1 || rect.height > contentH + 1; // tiny tolerance to reduce jitter at boundary
		};

		const applyAspect = (w, h) => {
			if (!w || !h) return;
			stageFrame.style.aspectRatio = `${w} / ${h}`;
		};

		const resetAspect = () => {
			stageFrame.style.aspectRatio = "16 / 9";
		};

		const getBaseAspect = () => {
			const base = getBase();
			if (base?.intrinsicWidth && base?.intrinsicHeight) return base.intrinsicWidth / base.intrinsicHeight;
			if (scene.referenceSize?.w && scene.referenceSize?.h) return scene.referenceSize.w / scene.referenceSize.h;
			return DEFAULT_ASPECT;
		};

		const updateStageFrameSize = () => {
			const aspect = getBaseAspect();
			stageFrame.style.aspectRatio = `${aspect}`;
			const viewportRect = viewportEl.getBoundingClientRect();
			const styles = getComputedStyle(viewportEl);
			const padX = (parseFloat(styles.paddingLeft) || 0) + (parseFloat(styles.paddingRight) || 0);
			const padY = (parseFloat(styles.paddingTop) || 0) + (parseFloat(styles.paddingBottom) || 0);
			const availableWidth = Math.max(320, viewportRect.width - padX);
			const availableHeight = Math.max(240, viewportRect.height - padY);
			const fullscreen = isFullscreenActive();
			const isLandscape = viewportRect.width >= viewportRect.height;
			const isMobilePortrait = !fullscreen && viewportRect.width <= 820 && viewportRect.height > viewportRect.width;
			const maxWidth = fullscreen ? availableWidth : 1800;
			const desktopMargin = fullscreen ? 0 : 96;
			const desktopHeight = Math.max(240, availableHeight - desktopMargin);

			let width;
			let height;

			if (fullscreen && isLandscape) {
				// Fit fullscreen while preserving aspect; avoid stretching that drifts overlays.
				const heightIfFullWidth = availableWidth / aspect;
				if (heightIfFullWidth <= availableHeight) {
					width = availableWidth;
					height = heightIfFullWidth;
				} else {
					height = availableHeight;
					width = height * aspect;
				}
				stageFrame.style.maxWidth = `${availableWidth}px`;
				stageFrame.style.maxHeight = `${availableHeight}px`;
			} else if (isMobilePortrait) {
				height = availableHeight;
				width = height * aspect;
				stageFrame.style.maxHeight = `${availableHeight}px`;
				stageFrame.style.maxWidth = `${width}px`;
			} else {
				width = Math.min(availableWidth, maxWidth);
				height = width / aspect;
				if (height > desktopHeight) {
					height = desktopHeight;
					width = Math.min(maxWidth, height * aspect);
				}
				stageFrame.style.maxWidth = `${availableWidth}px`;
				stageFrame.style.maxHeight = `${desktopHeight}px`;
			}

			stageFrame.style.width = `${width}px`;
			stageFrame.style.height = `${height}px`;
		};

		const updateFullscreenUI = () => {
			const active = isFullscreenActive();
			document.body.classList.toggle("fullscreen-active", active);
			if (fullscreenToggle) fullscreenToggle.textContent = active ? "Exit fullscreen" : "Fullscreen";
			if (active && currentZoom <= 1) {
				cameraOffset = { x: 0, y: 0 };
			}
			updateStageFrameSize();
			renderObjects();
			applyViewTransform();
			renderWebcamFxFrame();
		};

		const measureBaseIntrinsic = (obj) => {
			if (!obj?.base) return;
			const commit = (w, h) => {
				obj.intrinsicWidth = w;
				obj.intrinsicHeight = h;
				scene.referenceSize = { w, h };
				persistScene();
				applyAspect(w, h);
				updateStageFrameSize();
			};

			if (obj.kind === "image") {
				const img = new Image();
				img.onload = () => commit(img.naturalWidth || 1920, img.naturalHeight || 1080);
				img.src = obj.src;
			} else {
				const vid = document.createElement("video");
				vid.onloadedmetadata = () => commit(vid.videoWidth || 1920, vid.videoHeight || 1080);
				vid.src = obj.src;
			}
		};

		const ensureAspectFromBase = () => {
			const base = getBase();
			if (base) {
				if (base.intrinsicWidth && base.intrinsicHeight) {
					applyAspect(base.intrinsicWidth, base.intrinsicHeight);
				} else {
					measureBaseIntrinsic(base);
				}
				updateStageFrameSize();
				return;
			}
			resetAspect();
			updateStageFrameSize();
		};

		function getPerspectiveTransform(w, h, p) {
			const x0 = p[0].x, y0 = p[0].y;
			const x1 = p[1].x, y1 = p[1].y;
			const x2 = p[2].x, y2 = p[2].y;
			const x3 = p[3].x, y3 = p[3].y;
			const dx1 = x1 - x2, dy1 = y1 - y2;
			const dx2 = x3 - x2, dy2 = y3 - y2;
			const sx = x0 - x1 + x2 - x3, sy = y0 - y1 + y2 - y3;
			const det = dx1 * dy2 - dx2 * dy1;
			let g, i, a, b, c, d, e, f;
			if (det === 0) {
				g = 0; i = 0;
				a = x1 - x0; b = x3 - x0; c = x0;
				d = y1 - y0; e = y3 - y0; f = y0;
			} else {
				g = (sx * dy2 - sy * dx2) / det;
				i = (dx1 * sy - dy1 * sx) / det;
				a = x1 - x0 + g * x1;
				b = x3 - x0 + i * x3;
				c = x0;
				d = y1 - y0 + g * y1;
				e = y3 - y0 + i * y3;
				f = y0;
			}
			return `matrix3d(${a/w},${d/w},0,${g/w},${b/h},${e/h},0,${i/h},0,0,1,0,${c},${f},0,1)`;
		}

		let warpDragState = null;
		const beginWarpDrag = (e, obj, index) => {
			e.stopPropagation();
			const target = e.currentTarget;
			target.setPointerCapture(e.pointerId);
			const el = target.closest(".object");
			const rect = el.getBoundingClientRect();
			warpDragState = {
				objId: obj.id,
				index,
				startX: e.clientX,
				startY: e.clientY,
				startU: obj.warp[index].x,
				startV: obj.warp[index].y,
				width: rect.width,
				height: rect.height
			};
		};

		const moveWarpDrag = (e) => {
			if (!warpDragState) return;
			const dx = e.clientX - warpDragState.startX;
			const dy = e.clientY - warpDragState.startY;
			const du = dx / warpDragState.width;
			const dv = dy / warpDragState.height;
			const obj = scene.objects.find(o => o.id === warpDragState.objId);
			if (obj && obj.warp) {
				obj.warp[warpDragState.index].x = warpDragState.startU + du;
				obj.warp[warpDragState.index].y = warpDragState.startV + dv;
				renderObjects();
			}
		};

		const endWarpDrag = () => {
			if (warpDragState) {
				persistScene();
				warpDragState = null;
			}
		};

		window.addEventListener("pointermove", moveWarpDrag);
		window.addEventListener("pointerup", endWarpDrag);

		const updateWebcamFxAvailability = () => {
			const hasVideo = scene.objects.some(o => !o.hidden && o.kind === "video");
			if (hasVideo) {
				stopWebcamFxLoop();
				if (webcamFxToggle) {
					webcamFxToggle.disabled = true;
					webcamFxToggle.style.opacity = "0.5";
					webcamFxToggle.textContent = "Webcam FX: Off (Video)";
					webcamFxToggle.title = "Incompatible with video playback";
				}
			} else {
				if (webcamFxToggle) {
					webcamFxToggle.disabled = false;
					webcamFxToggle.style.opacity = "";
					webcamFxToggle.textContent = `Webcam FX: ${webcamFxEnabled ? "On" : "Off"}`;
					webcamFxToggle.title = "";
				}
				if (webcamFxEnabled) {
					startWebcamFxLoop();
				}
			}
		};

		const renderObjects = () => {
			objectLayer.innerHTML = "";
			ensureAspectFromBase();
			const { sx, sy, uni } = getScaleFactors();
			const sorted = [...scene.objects].sort((a, b) => a.z - b.z);
			const visible = sorted.filter((o) => !o.hidden);
			for (const obj of visible) {
				const el = document.createElement("div");
				const classes = ["object"];
				if (obj.locked) classes.push("locked");
				if (obj.base) classes.push("base");
				if (obj.warpEnabled) classes.push("warping");
				el.className = classes.join(" ");
				el.dataset.id = obj.id;

				if (obj.base) {
					obj.locked = true;
					obj.z = 0;
					el.style.inset = "0";
					el.style.zIndex = 0;
					el.style.transform = "none";
				} else {
					el.style.left = `${(obj.x ?? 0) * sx}px`;
					el.style.top = `${(obj.y ?? 0) * sy}px`;
					el.style.zIndex = obj.z;
					const effectiveScale = (obj.scale ?? 1) * uni;
					el.style.transform = `translate(-50%, -50%) scale(${effectiveScale})`;
				}

				if (obj.shadowEnabled && !obj.base) {
					const shadow = document.createElement("div");
					shadow.className = "shadow";
					const shadowSize = (obj.shadowSize ?? 220) * uni * (obj.scale ?? 1);
					shadow.style.setProperty("--shadow-size", `${shadowSize}px`);
					shadow.style.setProperty("--shadow-opacity", obj.shadowOpacity ?? 0.45);
					shadow.style.setProperty("--shadow-offset-x", `${(obj.shadowOffsetX ?? 0) * sx}px`);
					shadow.style.setProperty("--shadow-offset-y", `${(obj.shadowOffsetY ?? 0) * sy}px`);
					el.appendChild(shadow);
				}

				let media;
				if (obj.kind === "video") {
					media = document.createElement("video");
					media.src = obj.src;
					media.autoplay = true;
					media.loop = true;
					media.playsInline = true;
					media.muted = true;
					const tryPlay = () => media.play().catch(() => {});
					media.addEventListener("loadeddata", tryPlay, { once: true });
					media.addEventListener("canplay", tryPlay, { once: true });
					setTimeout(tryPlay, 0);
				} else {
					media = document.createElement("img");
					media.src = obj.src;
					media.loading = "lazy";
					media.decoding = "async";
				}

				if (obj.warpEnabled && obj.warp && obj.warp.length === 4) {
					if (!obj.intrinsicWidth) {
						const updateSize = () => {
							const w = media.videoWidth || media.naturalWidth;
							const h = media.videoHeight || media.naturalHeight;
							if (w && h) {
								obj.intrinsicWidth = w;
								obj.intrinsicHeight = h;
								renderObjects();
							}
						};
						if (media.readyState >= 1 || media.complete) {
							updateSize();
						} else {
							media.addEventListener(media.tagName === "VIDEO" ? "loadedmetadata" : "load", updateSize);
						}
					}

					const w = obj.intrinsicWidth || 320;
					const h = obj.intrinsicHeight || 240;
					const p = obj.warp.map(pt => ({x: pt.x * w, y: pt.y * h}));
					media.style.transform = getPerspectiveTransform(w, h, p);
					media.style.transformOrigin = "0 0";
					
					if (!obj.locked) {
						obj.warp.forEach((pt, idx) => {
							const handle = document.createElement("div");
							handle.className = "warp-handle";
							handle.style.left = `${pt.x * 100}%`;
							handle.style.top = `${pt.y * 100}%`;
							handle.addEventListener("pointerdown", (e) => beginWarpDrag(e, obj, idx));
							el.appendChild(handle);
						});
					}
				}

				el.appendChild(media);

				if (!obj.base) {
					el.addEventListener("pointerdown", (e) => beginDrag(e, obj));
					el.addEventListener("wheel", (e) => scaleObjectWheel(e, obj));
				}

				objectLayer.appendChild(el);
			}
			updateListUI();
			dropHint.style.display = visible.length ? "none" : "grid";
			updateWebcamFxAvailability();
		};

		const addObject = ({ src, name, sourceType, base = false }) => {
			if (!src) return;
			const { x, y } = centerCoords();
			const zMax = scene.objects.reduce((m, o) => (o.base ? m : Math.max(m, o.z ?? 0)), 0);
			const kind = isVideo(name) ? "video" : "image";
			const obj = {
				id: nextId(),
				name: name || "object",
				alias: name || "object",
				src,
				sourceType: sourceType || "file", // file | data
				kind,
				x,
				y,
				scale: 1,
				z: base ? 0 : zMax + 1,
				locked: !!base,
				base: !!base,
				hidden: false,
				shadowEnabled: !base,
				shadowSize: 220,
				shadowOpacity: 0.45,
				shadowOffsetX: 0,
				shadowOffsetY: 0,
			};

			if (base) {
				scene.objects.forEach((o) => (o.base = false));
			}

			scene.objects.push(obj);
			collapsedState.set(obj.id, true);
			if (base) measureBaseIntrinsic(obj);
			persistScene();
			renderObjects();
		};

		const toggleBase = (id) => {
			const target = scene.objects.find((o) => o.id === id);
			if (!target) return;
			const wasBase = target.base;
			scene.objects.forEach((o) => {
				o.base = false;
				if (o.z === 0) o.z = 1;
			});
			if (!wasBase) {
				target.base = true;
				target.locked = true;
				target.z = 0;
				target.x = centerCoords().x;
				target.y = centerCoords().y;
				measureBaseIntrinsic(target);
			} else {
				target.locked = false;
			}
			persistScene();
			renderObjects();
		};

		const beginDrag = (event, obj) => {
			const zoomLocked = Math.abs(currentZoom - 1) > 0.001;
			if (obj.locked || obj.hidden || zoomLocked || webcamFxEnabled) return;
			const target = event.currentTarget;
			target.setPointerCapture(event.pointerId);
			const { sx, sy } = getScaleFactors();
			dragState = {
				id: obj.id,
				startX: event.clientX,
				startY: event.clientY,
				originX: obj.x,
				originY: obj.y,
				sx,
				sy,
			};
			stage.classList.add("dragging");
			target.style.cursor = "grabbing";
			event.preventDefault();
		};

		const moveDrag = (event) => {
			if (!dragState) return;
			const obj = scene.objects.find((o) => o.id === dragState.id);
			if (!obj || obj.locked || obj.hidden) return;
			const dx = (event.clientX - dragState.startX) / (dragState.sx || 1);
			const dy = (event.clientY - dragState.startY) / (dragState.sy || 1);
			obj.x = dragState.originX + dx;
			obj.y = dragState.originY + dy;
			persistScene();
			renderObjects();
		};

		const endDrag = () => {
			dragState = null;
			stage.classList.remove("dragging");
		};

		const scaleObjectWheel = (event, obj) => {
			if (!event.shiftKey || obj.locked || obj.hidden) return;
			event.preventDefault();
			const delta = -event.deltaY;
			const factor = delta > 0 ? 1.04 : 0.96;
			obj.scale = clamp((obj.scale ?? 1) * factor, 0.1, 8);
			persistScene();
			renderObjects();
		};

		const toggleModal = (show) => {
			modalOverlay.style.display = show ? "flex" : "none";
		};

		const updateListUI = () => {
			objectList.innerHTML = "";
			const ordered = [...scene.objects].sort((a, b) => a.z - b.z);
			const term = (filterTerm || "").trim().toLowerCase();
			const filtered = term
				? ordered.filter((o) => {
					const alias = (o.alias || "").toLowerCase();
					const name = (o.name || "").toLowerCase();
					return alias.includes(term) || name.includes(term);
				})
				: ordered;

			if (!filtered.length) {
				const empty = document.createElement("div");
				empty.className = "badge";
				empty.textContent = term ? "No objects match filter" : "No objects yet";
				objectList.appendChild(empty);
				return;
			}

			for (const obj of filtered) {
				ensureAlias(obj);
				if (!collapsedState.has(obj.id)) collapsedState.set(obj.id, true);
				const isCollapsed = collapsedState.get(obj.id);

				const card = document.createElement("div");
				card.className = `card${isCollapsed ? " collapsed" : ""}`;

				const header = document.createElement("div");
				header.className = "controlRow";

				const collapseBtn = document.createElement("button");
				collapseBtn.className = "iconBtn";
				collapseBtn.textContent = isCollapsed ? "â–¸" : "â–¾";
				collapseBtn.title = isCollapsed ? "Expand" : "Collapse";
				collapseBtn.addEventListener("click", () => {
					collapsedState.set(obj.id, !isCollapsed);
					updateListUI();
				});
				header.appendChild(collapseBtn);

				const title = document.createElement("div");
				title.className = "cardHeaderTitle";
				title.textContent = obj.alias || obj.name;
				header.appendChild(title);

				const badge = document.createElement("div");
				badge.className = "badge";
				badge.textContent = `${obj.kind} Â· z${obj.z}`;
				header.appendChild(badge);

				const lockBadge = document.createElement("div");
				lockBadge.className = "badge";
				lockBadge.textContent = obj.base ? "Base" : obj.hidden ? "Hidden" : obj.locked ? "Locked" : "Unlocked";
				header.appendChild(lockBadge);

				const headerActions = document.createElement("div");
				headerActions.style.display = "flex";
				headerActions.style.gap = "6px";

				const miniVisBtn = document.createElement("button");
				miniVisBtn.className = "iconBtn miniIconBtn";
				const syncMiniVis = () => {
					miniVisBtn.textContent = obj.hidden ? "ðŸ™ˆ" : "ðŸ‘";
					miniVisBtn.title = obj.hidden ? "Show object" : "Hide object";
				};
				syncMiniVis();
				miniVisBtn.disabled = obj.base;
				miniVisBtn.addEventListener("click", (e) => {
					e.stopPropagation();
					if (obj.base) return;
					obj.hidden = !obj.hidden;
					syncMiniVis();
					persistScene();
					renderObjects();
				});
				headerActions.appendChild(miniVisBtn);

				const miniLockBtn = document.createElement("button");
				miniLockBtn.className = "iconBtn miniIconBtn";
				const syncMiniLock = () => {
					miniLockBtn.textContent = obj.locked ? "ðŸ”’" : "ðŸ”“";
					miniLockBtn.title = obj.locked ? "Unlock" : "Lock";
				};
				syncMiniLock();
				miniLockBtn.disabled = obj.base;
				miniLockBtn.addEventListener("click", (e) => {
					e.stopPropagation();
					if (obj.base) return;
					obj.locked = !obj.locked;
					syncMiniLock();
					persistScene();
					renderObjects();
				});
				headerActions.appendChild(miniLockBtn);

				const miniWarpBtn = document.createElement("button");
				miniWarpBtn.className = "iconBtn miniIconBtn";
				miniWarpBtn.textContent = "â›¶";
				miniWarpBtn.title = "Toggle Warp Mode";
				miniWarpBtn.style.background = obj.warpEnabled ? "var(--accent)" : "";
				miniWarpBtn.style.color = obj.warpEnabled ? "#000" : "";
				miniWarpBtn.disabled = obj.base;
				miniWarpBtn.addEventListener("click", (e) => {
					e.stopPropagation();
					if (obj.base) return;
					obj.warpEnabled = !obj.warpEnabled;
					if (obj.warpEnabled && !obj.warp) {
						obj.warp = [
							{x: 0, y: 0},
							{x: 1, y: 0},
							{x: 1, y: 1},
							{x: 0, y: 1}
						];
					}
					persistScene();
					renderObjects();
				});
				headerActions.appendChild(miniWarpBtn);

				header.appendChild(headerActions);

				card.appendChild(header);

				const details = document.createElement("div");
				details.className = "cardDetails";

				const applyFilterVisibility = () => {
					if (!filterTerm.trim()) {
						card.classList.remove("hidden");
						return;
					}
					const term = filterTerm.trim().toLowerCase();
					const match = (obj.alias || "").toLowerCase().includes(term) || (obj.name || "").toLowerCase().includes(term);
					card.classList.toggle("hidden", !match);
				};

				const aliasRow = document.createElement("div");
				aliasRow.className = "controlRow";
				const aliasInputId = `alias-${obj.id}`;
				const aliasLabel = document.createElement("label");
				aliasLabel.className = "inlineLabel";
				aliasLabel.htmlFor = aliasInputId;
				aliasLabel.textContent = "Alias:";
				aliasRow.appendChild(aliasLabel);
				const aliasInput = document.createElement("input");
				aliasInput.type = "text";
				aliasInput.placeholder = "Alias";
				aliasInput.id = aliasInputId;
				aliasInput.value = obj.alias || "";
				aliasInput.addEventListener("input", () => {
					obj.alias = aliasInput.value;
					ensureAlias(obj);
					title.textContent = obj.alias || obj.name;
					persistScene();
					applyFilterVisibility();
				});
				aliasInput.addEventListener("blur", () => {
					ensureAlias(obj);
					title.textContent = obj.alias || obj.name;
					updateListUI();
				});
				aliasRow.appendChild(aliasInput);

				const nameInputId = `name-${obj.id}`;
				const nameLabel = document.createElement("label");
				nameLabel.className = "inlineLabel";
				nameLabel.htmlFor = nameInputId;
				nameLabel.textContent = "File:";
				aliasRow.appendChild(nameLabel);
				const nameInput = document.createElement("input");
				nameInput.type = "text";
				nameInput.id = nameInputId;
				nameInput.value = obj.name;
				nameInput.placeholder = "Name / filename";
				nameInput.addEventListener("input", () => {
					obj.name = nameInput.value;
					persistScene();
					applyFilterVisibility();
				});
				aliasRow.appendChild(nameInput);

				const baseBtn = document.createElement("button");
				baseBtn.className = "iconBtn";
				baseBtn.textContent = obj.base ? "â˜…" : "â˜†";
				baseBtn.title = obj.base ? "Unset base" : "Set as base background";
				baseBtn.addEventListener("click", () => toggleBase(obj.id));
				aliasRow.appendChild(baseBtn);

				const visibilityBtn = document.createElement("button");
				visibilityBtn.className = "iconBtn";
				const syncVisibilityBtn = () => {
					visibilityBtn.textContent = obj.hidden ? "ðŸ™ˆ" : "ðŸ‘";
					visibilityBtn.title = obj.hidden ? "Show object" : "Hide object";
				};
				syncVisibilityBtn();
				visibilityBtn.disabled = obj.base;
				visibilityBtn.addEventListener("click", () => {
					if (obj.base) return;
					obj.hidden = !obj.hidden;
					syncVisibilityBtn();
					persistScene();
					renderObjects();
				});
				aliasRow.appendChild(visibilityBtn);

				const lockBtn = document.createElement("button");
				lockBtn.className = "iconBtn";
				lockBtn.textContent = obj.locked ? "ðŸ”’" : "ðŸ”“";
				lockBtn.title = "Lock / unlock";
				lockBtn.disabled = obj.base;
				lockBtn.addEventListener("click", () => {
					if (obj.base) return;
					obj.locked = !obj.locked;
					persistScene();
					renderObjects();
				});
				aliasRow.appendChild(lockBtn);
				details.appendChild(aliasRow);

				if (obj.base) {
					const baseBadge = document.createElement("div");
					baseBadge.className = "badge";
					baseBadge.textContent = "Base background (fills canvas)";
					details.appendChild(baseBadge);
				} else {
					const scaleRow = document.createElement("div");
					scaleRow.className = "controlRow compact";
					const scaleLabel = document.createElement("div");
					scaleLabel.className = "badge";
					scaleLabel.textContent = "Scale";
					scaleRow.appendChild(scaleLabel);
					const scaleInput = document.createElement("input");
					scaleInput.type = "number";
					scaleInput.min = "10";
					scaleInput.max = "800";
					scaleInput.value = Math.round((obj.scale ?? 1) * 100);
					scaleInput.style.width = "86px";
					scaleInput.addEventListener("change", () => {
						const pct = clamp(Number(scaleInput.value) || 100, 10, 800);
						scaleInput.value = pct;
						obj.scale = pct / 100;
						persistScene();
						renderObjects();
					});
					scaleRow.appendChild(scaleInput);
					[50, 100, 200].forEach((pct) => {
						const b = document.createElement("button");
						b.className = "iconBtn";
						b.textContent = `${pct}%`;
						b.addEventListener("click", () => {
							obj.scale = pct / 100;
							persistScene();
							renderObjects();
						});
						scaleRow.appendChild(b);
					});
					details.appendChild(scaleRow);

					const shadowRow = document.createElement("div");
					shadowRow.className = "controlRow compact";
					const shadowToggle = document.createElement("button");
					shadowToggle.className = "iconBtn";
					shadowToggle.textContent = obj.shadowEnabled ? "Shadow on" : "Shadow off";
					shadowToggle.addEventListener("click", () => {
						obj.shadowEnabled = !obj.shadowEnabled;
						persistScene();
						renderObjects();
					});
					shadowRow.appendChild(shadowToggle);

					const shadowSize = document.createElement("input");
					shadowSize.type = "number";
					shadowSize.min = "50";
					shadowSize.max = "1000";
					shadowSize.value = Math.round(obj.shadowSize ?? 220);
					shadowSize.style.width = "86px";
					shadowSize.addEventListener("change", () => {
						const val = clamp(Number(shadowSize.value) || 220, 50, 1000);
						shadowSize.value = val;
						obj.shadowSize = val;
						persistScene();
						renderObjects();
					});
					shadowRow.appendChild(shadowSize);

					const shadowOpacity = document.createElement("input");
					shadowOpacity.type = "range";
					shadowOpacity.min = "0";
					shadowOpacity.max = "1";
					shadowOpacity.step = "0.01";
					shadowOpacity.value = obj.shadowOpacity ?? 0.45;
					shadowOpacity.style.width = "120px";
					shadowOpacity.addEventListener("input", () => {
						obj.shadowOpacity = clamp(Number(shadowOpacity.value) || 0, 0, 1);
						persistScene();
						renderObjects();
					});
					shadowRow.appendChild(shadowOpacity);

					const shadowOffsetX = document.createElement("input");
					shadowOffsetX.type = "number";
					shadowOffsetX.min = "-300";
					shadowOffsetX.max = "300";
					shadowOffsetX.value = Math.round(obj.shadowOffsetX ?? 0);
					shadowOffsetX.style.width = "72px";
					shadowOffsetX.addEventListener("change", () => {
						const val = clamp(Number(shadowOffsetX.value) || 0, -300, 300);
						shadowOffsetX.value = val;
						obj.shadowOffsetX = val;
						persistScene();
						renderObjects();
					});
					shadowRow.appendChild(shadowOffsetX);

					const shadowOffsetY = document.createElement("input");
					shadowOffsetY.type = "number";
					shadowOffsetY.min = "-300";
					shadowOffsetY.max = "300";
					shadowOffsetY.value = Math.round(obj.shadowOffsetY ?? 0);
					shadowOffsetY.style.width = "72px";
					shadowOffsetY.addEventListener("change", () => {
						const val = clamp(Number(shadowOffsetY.value) || 0, -300, 300);
						shadowOffsetY.value = val;
						obj.shadowOffsetY = val;
						persistScene();
						renderObjects();
					});
					shadowRow.appendChild(shadowOffsetY);

					details.appendChild(shadowRow);
				}

				const actions = document.createElement("div");
				actions.className = "listActions";

				const up = document.createElement("button");
				up.className = "iconBtn iconLabelBtn";
				up.innerHTML = "â¬†<span class=\"btnLabel\">Up</span>";
				up.title = "Bring forward";
				up.disabled = obj.base;
				up.addEventListener("click", () => moveZ(obj.id, 1));
				actions.appendChild(up);

				const down = document.createElement("button");
				down.className = "iconBtn iconLabelBtn";
				down.innerHTML = "â¬‡<span class=\"btnLabel\">Down</span>";
				down.title = "Send backward";
				down.disabled = obj.base;
				down.addEventListener("click", () => moveZ(obj.id, -1));
				actions.appendChild(down);

				const duplicate = document.createElement("button");
				duplicate.className = "iconBtn iconLabelBtn";
				duplicate.innerHTML = "â§‰<span class=\"btnLabel\">Copy</span>";
				duplicate.title = "Duplicate";
				duplicate.addEventListener("click", () => duplicateObject(obj.id));
				actions.appendChild(duplicate);

				const resetBtn = document.createElement("button");
				resetBtn.className = "iconBtn iconLabelBtn";
				resetBtn.innerHTML = "â†º<span class=\"btnLabel\">Reset</span>";
				resetBtn.title = "Reset position & size";
				resetBtn.disabled = obj.base;
				resetBtn.addEventListener("click", () => resetObject(obj.id));
				actions.appendChild(resetBtn);

				const del = document.createElement("button");
				del.className = "iconBtn iconLabelBtn";
				del.innerHTML = "âœ•<span class=\"btnLabel\">Delete</span>";
				del.title = "Delete";
				del.addEventListener("click", () => deleteObject(obj.id));
				actions.appendChild(del);

				details.appendChild(actions);
				card.appendChild(details);
				objectList.appendChild(card);
			}
		};

		const moveZ = (id, dir) => {
			const sorted = [...scene.objects].filter((o) => !o.base).sort((a, b) => a.z - b.z);
			const idx = sorted.findIndex((o) => o.id === id);
			if (idx === -1) return;
			const targetIdx = clamp(idx + dir, 0, sorted.length - 1);
			const [item] = sorted.splice(idx, 1);
			sorted.splice(targetIdx, 0, item);
			sorted.forEach((o, i) => (o.z = i + 1));

			const base = getBase();
			const merged = base ? [base, ...sorted] : sorted;
			scene.objects = merged;
			persistScene();
			renderObjects();
		};

		const duplicateObject = (id) => {
			const source = scene.objects.find((o) => o.id === id);
			if (!source) return;
			const zMax = scene.objects.reduce((m, o) => (o.base ? m : Math.max(m, o.z ?? 0)), 0);
			const center = centerCoords();
			const copy = {
				...source,
				id: nextId(),
				name: `${source.name || "object"} copy`,
				alias: `${source.alias || source.name || "object"} copy`,
				base: false,
				locked: false,
					hidden: source.hidden ?? false,
				z: zMax + 1,
				x: (source.x ?? center.x) + 20,
				y: (source.y ?? center.y) + 20,
				sourceType: source.sourceType,
			};
			collapsedState.set(copy.id, true);
			scene.objects.push(copy);
			persistScene();
			renderObjects();
		};

		const resetObject = (id) => {
			const obj = scene.objects.find((o) => o.id === id);
			if (!obj || obj.base) return;
			const center = centerCoords();
			obj.x = center.x;
			obj.y = center.y;
			obj.scale = 1;
			obj.shadowSize = 220;
			obj.shadowOpacity = 0.45;
			obj.shadowOffsetX = 0;
			obj.shadowOffsetY = 0;
			persistScene();
			renderObjects();
		};

		const deleteObject = (id) => {
			collapsedState.delete(id);
			scene.objects = scene.objects.filter((o) => o.id !== id);
			persistScene();
			renderObjects();
		};

		const setLockAll = (locked) => {
			let changed = false;
			scene.objects.forEach((o) => {
				if (o.base) return;
				if (o.locked !== locked) {
					o.locked = locked;
					changed = true;
				}
			});
			if (changed) {
				persistScene();
				renderObjects();
			}
		};

		const applyViewTransform = (relaxed = false) => {
			// Clamp against the actual visible window (stageScroller/stageFrame), not the full viewport.
			// Using the viewport introduces an artificial "margin" wall when the viewport is larger than the stage frame.
			const rect = stageScroller.getBoundingClientRect();
			const contentW = Math.max(1, rect.width);
			const contentH = Math.max(1, rect.height);
			if (currentZoom <= 1) {
				cameraOffset = { x: 0, y: 0 };
			}
			const baseSlack = 8; // small baseline slack to avoid zero-span clamping due to rounding
			const slack = baseSlack + (relaxed ? 24 : 0); // soften edge clamping during drag
			const maxX = Math.max(0, (rect.width * currentZoom - contentW) / 2) + slack;
			const maxY = Math.max(0, (rect.height * currentZoom - contentH) / 2) + slack;
			cameraOffset.x = clamp(cameraOffset.x, -maxX, maxX);
			cameraOffset.y = clamp(cameraOffset.y, -maxY, maxY);
			const transform = `translate(${cameraOffset.x}px, ${cameraOffset.y}px) scale(${currentZoom})`;
			stage.style.transform = transform;
			stageFrame.style.transform = "";
			if (webcamFxCanvas) {
				webcamFxCanvas.style.transform = transform;
				webcamFxCanvas.style.transformOrigin = stage.style.transformOrigin || "center center";
			}
		};

		const setZoom = (value) => {
			const clamped = clamp(value, 0.5, 2.5);
			currentZoom = clamped;
			zoomSlider.value = clamped;
			zoomValue.textContent = `${Math.round(clamped * 100)}%`;
			stage.style.setProperty("--global-zoom", clamped);
			if (currentZoom <= 1) cameraOffset = { x: 0, y: 0 };
			applyViewTransform();
		};

		const resetCamera = () => {
			cameraOffset = { x: 0, y: 0 };
			setZoom(1);
		};

		const handleDrop = async (event) => {
			event.preventDefault();
			const files = Array.from(event.dataTransfer?.files || []);
			for (const file of files) {
				const dataUrl = await fileToDataURL(file);
				addObject({ src: dataUrl, name: file.name, sourceType: "data" });
			}
		};

		const fileToDataURL = (file) => new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onload = () => resolve(reader.result);
			reader.onerror = reject;
			reader.readAsDataURL(file);
		});

		const checkFileExists = async (url) => {
			try {
				const res = await fetch(url, { method: "HEAD", cache: "no-cache" });
				return res.ok;
			} catch (err) {
				return false;
			}
		};

		const upgradeDataSourcesForExport = async () => {
			let changed = false;
			const tasks = scene.objects.map(async (o) => {
				if (o.sourceType !== "data") return;
				const candidate = (o.name || "").trim();
				if (!candidate) return;
				const exists = await checkFileExists(candidate);
				if (exists) {
					o.sourceType = "file";
					o.src = candidate;
					changed = true;
				}
			});
			await Promise.all(tasks);
			if (changed) {
				persistScene();
			}
		};

		const downloadScene = async () => {
			await upgradeDataSourcesForExport();
			const exportable = scene.objects
				.filter((o) => o.sourceType !== "data")
				.map((o) => ({
					id: o.id,
					name: o.name,
					alias: o.alias,
					src: o.src,
					sourceType: o.sourceType,
					kind: o.kind,
					x: o.x,
					y: o.y,
					scale: o.scale,
					z: o.z,
					locked: o.locked,
					base: o.base,
					hidden: o.hidden,
					intrinsicWidth: o.intrinsicWidth,
					intrinsicHeight: o.intrinsicHeight,
					shadowEnabled: o.shadowEnabled,
					shadowSize: o.shadowSize,
					shadowOpacity: o.shadowOpacity,
					shadowOffsetX: o.shadowOffsetX,
					shadowOffsetY: o.shadowOffsetY,
					warpEnabled: !!o.warpEnabled,
					warp: Array.isArray(o.warp)
						? o.warp.map((pt) => ({ x: pt.x, y: pt.y }))
						: undefined,
				}));
			const payload = JSON.stringify({
				objects: exportable,
				referenceSize: scene.referenceSize,
				subtitle: scene.subtitle || "",
				music: scene.music || "",
			}, null, 2);
			const blob = new Blob([payload], { type: "application/json" });
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = "default.json";
			a.click();
			URL.revokeObjectURL(url);
		};

		const importScene = (text) => {
			try {
				const data = JSON.parse(text);
				const imported = Array.isArray(data.objects) ? data.objects : [];
					const existingDataObjects = scene.objects.filter((o) => o.sourceType === "data");
				let baseTaken = false;
				const normalised = imported.map((o, i) => {
					const asBase = !!o.base && !baseTaken;
					baseTaken = baseTaken || asBase;
					const warp = Array.isArray(o.warp) && o.warp.length === 4
						? o.warp.map((pt) => ({
							x: Number(pt?.x ?? 0) || 0,
							y: Number(pt?.y ?? 0) || 0,
						}))
						: undefined;
					const warpEnabled = !!o.warpEnabled && !!warp;
					return {
						id: o.id || nextId(),
						name: o.name || `object-${i}`,
							alias: o.alias || o.name || `object-${i}`,
						src: o.src,
						sourceType: "file",
						kind: o.kind || (isVideo(o.name || "") ? "video" : "image"),
						x: o.x ?? centerCoords().x,
						y: o.y ?? centerCoords().y,
						scale: o.scale ?? 1,
						z: asBase ? 0 : (o.z ?? i + 1),
						locked: asBase ? true : !!o.locked,
						base: asBase,
						hidden: !!o.hidden,
						intrinsicWidth: o.intrinsicWidth,
						intrinsicHeight: o.intrinsicHeight,
						shadowEnabled: o.shadowEnabled ?? !asBase,
						shadowSize: o.shadowSize ?? 220,
						shadowOpacity: o.shadowOpacity ?? 0.45,
						shadowOffsetX: o.shadowOffsetX ?? 0,
						shadowOffsetY: o.shadowOffsetY ?? 0,
						warpEnabled,
						warp,
					};
				});
				scene.objects = [...existingDataObjects, ...normalised];
					scene.objects.forEach(ensureAlias);
				if (data.referenceSize && data.referenceSize.w && data.referenceSize.h) {
					scene.referenceSize = data.referenceSize;
				}
				const wasPlaying = !music.paused;
				scene.subtitle = typeof data.subtitle === "string" ? data.subtitle : "";
				scene.music = typeof data.music === "string" ? data.music : "";
				setMusicSource(getMusicSource());
				if (wasPlaying) startMusic();
				persistScene();
				renderObjects();
				renderSubtitle();
			} catch (err) {
				console.error("Failed to import", err);
				alert("Could not import scene JSON");
			}
		};

		const clearAll = () => {
			if (!confirm("Clear scene? This keeps nothing.")) return;
			scene.objects = [];
			scene.subtitle = "";
			persistScene();
			renderObjects();
			renderSubtitle();
		};

		const setExternalMusicActive = (active) => {
			externalMusicActive = !!active;
			if (externalMusicActive) {
				try { music.pause(); } catch (err) {}
			} else if (EMBED_MODE && music.paused) {
				startMusic();
			}
		};

		// Event wiring
		menuToggle.addEventListener("click", () => toggleModal(true));
		modalOverlay.addEventListener("click", (e) => {
			if (e.target === modalOverlay) toggleModal(false);
		});

		hudToggle.addEventListener("click", () => {
			hud.classList.toggle("collapsed");
			const isCollapsed = hud.classList.contains("collapsed");
			hudToggle.textContent = isCollapsed ? "â–¸" : "â–¾";
			window.parent.postMessage({ type: 'camera-control-toggle', collapsed: isCollapsed }, '*');
		});

		if (fullscreenToggle) {
			fullscreenToggle.addEventListener("click", toggleFullscreen);
			document.addEventListener("fullscreenchange", updateFullscreenUI);
		}

		const hideWelcome = () => {
			welcomeOverlay.style.display = "none";
		};

		welcomeCard.addEventListener("click", hideWelcome);
		welcomeOverlay.addEventListener("click", hideWelcome);

		zoomSlider.addEventListener("input", (e) => setZoom(parseFloat(e.target.value)));
		resetView.addEventListener("click", resetCamera);
		if (webcamFxToggle) {
			webcamFxToggle.addEventListener("click", () => setWebcamFxEnabled(!webcamFxEnabled));
		}

		downloadJson.addEventListener("click", downloadScene);
		uploadJson.addEventListener("change", (e) => {
			const file = e.target.files?.[0];
			if (!file) return;
			file.text().then(importScene);
			uploadJson.value = "";
		});

		clearScene.addEventListener("click", clearAll);

		if (autoImportToggle) {
			autoImportToggle.checked = autoImportEnabled;
			autoImportToggle.addEventListener("change", (e) => {
				persistAutoImportPreference(!!e.target.checked);
			});
		}

		if (objectFilter) {
			objectFilter.addEventListener("input", (e) => {
				filterTerm = e.target.value || "";
				if (clearFilterBtn) clearFilterBtn.disabled = !filterTerm.trim();
				updateListUI();
			});
		}

		if (clearFilterBtn && objectFilter) {
			clearFilterBtn.addEventListener("click", () => {
				filterTerm = "";
				objectFilter.value = "";
				clearFilterBtn.disabled = true;
				updateListUI();
				objectFilter.focus();
			});
			clearFilterBtn.disabled = true;
		}

		if (unlockAllBtn) {
			unlockAllBtn.addEventListener("click", () => setLockAll(false));
		}

		if (lockAllBtn) {
			lockAllBtn.addEventListener("click", () => setLockAll(true));
		}

		addByName.addEventListener("click", () => {
			const value = filenameInput.value.trim();
			if (!value) return;
			addObject({ src: value, name: value, sourceType: "file" });
			filenameInput.value = "";
		});

		if (subtitleInput) {
			subtitleInput.addEventListener("input", () => {
				scene.subtitle = subtitleInput.value;
				persistScene();
				renderSubtitle();
			});
		}

		if (musicInput) {
			musicInput.addEventListener("input", () => {
				scene.music = musicInput.value;
				persistScene();
				setMusicSource(getMusicSource());
			});
		}

		window.unlock = () => {
			devUnlocked = true;
			persistDevUnlockState();
			applyDevUnlockState();
		};

		window.lock = () => {
			devUnlocked = false;
			persistDevUnlockState();
			applyDevUnlockState();
		};

		stage.addEventListener("dragover", (e) => {
			e.preventDefault();
		});
		stage.addEventListener("drop", handleDrop);
		stage.addEventListener("pointerdown", beginPan);
		stage.addEventListener("pointermove", movePan);
		stage.addEventListener("pointerup", endPan);
		objectLayer.addEventListener("pointerdown", (e) => {
			if (e.target === objectLayer) beginPan(e);
		});
		objectLayer.addEventListener("pointermove", movePan);
		objectLayer.addEventListener("pointerup", endPan);

		window.addEventListener("pointermove", moveDrag);
		window.addEventListener("pointerup", endDrag);
		window.addEventListener("pointerup", endPan);
		music.addEventListener("volumechange", enforceMusicCeiling);
		music.addEventListener("play", enforceMusicCeiling);
		document.addEventListener("visibilitychange", () => {
			if (document.visibilityState === "visible") enforceMusicCeiling();
		});
		window.addEventListener("pagehide", () => fadeOutAndStopMusic());
		window.addEventListener("message", (event) => {
			const data = event?.data;
			if (data && data.type === "background-music-state") {
				setExternalMusicActive(!!data.playing);
			}
		});

		// Prevent browser navigating away on file drop.
		window.addEventListener("dragover", (e) => e.preventDefault());
		window.addEventListener("drop", (e) => {
			if (!e.target.closest || !e.target.closest("#stage")) e.preventDefault();
		});

		window.addEventListener("resize", () => {
			if (resizeRaf) cancelAnimationFrame(resizeRaf);
			resizeRaf = requestAnimationFrame(() => {
				resizeRaf = null;
				renderObjects();
				applyViewTransform();
				renderWebcamFxFrame();
			});
		});

		function beginPan(event) {
			const overflowOk = hasViewportOverflow();
			if (dragState || (currentZoom <= 1 && !overflowOk)) return;
			if (event.button !== undefined && event.button !== 0) return;
			const target = event.currentTarget;
			target.setPointerCapture(event.pointerId);
			panState = {
				startX: event.clientX,
				startY: event.clientY,
				originX: cameraOffset.x,
				originY: cameraOffset.y,
			};
			stage.classList.add("dragging");
		}

		function movePan(event) {
			if (!panState) return;
			event.preventDefault();
			const dx = event.clientX - panState.startX;
			const dy = event.clientY - panState.startY;
			cameraOffset.x = panState.originX + dx;
			cameraOffset.y = panState.originY + dy;
			applyViewTransform(true);
		}

		function endPan() {
			panState = null;
			stage.classList.remove("dragging");
			applyViewTransform();
		}

		const init = async () => {
			autoImportEnabled = loadAutoImportPreference();
			if (autoImportToggle) autoImportToggle.checked = autoImportEnabled;
			loadScene();
			loadDevUnlockState();
			loadWebcamFxState();
			setZoom(parseFloat(zoomSlider.value));
			renderObjects();
			renderSubtitle();
			setupWebcamFxRamp();
			setWebcamFxEnabled(webcamFxEnabled);
			await autoImportDefaultScene();
			if (subtitleInput) subtitleInput.value = scene.subtitle || "";
			if (musicInput) musicInput.value = scene.music || "";
			updateFullscreenUI();
			applyViewTransform();
			setMusicSource(getMusicSource());
			startMusic();
		};

		document.addEventListener("keydown", (e) => {
			if (e.key === "Escape") toggleModal(false);
		});

		init();
	</script>
</body>
</html>

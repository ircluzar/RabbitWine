<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realities - Camera</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon.png">
    <link rel="manifest" href="../manifest.json">
    <link rel="stylesheet" href="../mainmenu.css">
    <link rel="stylesheet" href="../stars.css">
    <link rel="stylesheet" href="../modals.css">
    <link rel="stylesheet" href="realities.css">
    <script src="../miniPlayer.js"></script>
    <style>
    html, body {
        height: auto !important;
        overflow-y: auto !important;
        overflow-x: hidden;
        overscroll-behavior: auto !important;
        touch-action: auto !important;
        min-height: 100vh;
        margin: 0;
        padding: 0;
    }
    
    .background-animation {
        position: fixed !important;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh !important;
        z-index: 0 !important;
        pointer-events: none;
    }
    
    .realities-main {
        max-width: 600px;
        margin: 0 auto;
        padding: 20px 8px 40px 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        position: relative;
        z-index: 2;
        height: auto;
        min-height: 100vh;
        margin-top: 32px;
    }
    .camera-card {
        background: var(--bg-accent);
        border-radius: 22px;
        box-shadow: 0 2px 8px rgba(204,188,252,0.07);
        border: 1.5px solid var(--border-color);
        padding: 18px 18px 12px 18px;
        margin-bottom: 2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 560px;
    }
    .viewfinder {
        width: 560px;
        height: 420px;
        background: #222;
        border-radius: 16px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 1rem;
        border: 2px solid var(--accent-purple);
        box-shadow: 0 4px 24px rgba(204,188,252,0.13);
    }
    .camera-btn {
        min-width: 64px;
        min-height: 64px;
        border-radius: 50%;
        font-size: 2.2rem;
        background: var(--accent-purple);
        color: #1a1626;
        border: none;
        box-shadow: 0 2px 8px rgba(204,188,252,0.08);
        cursor: pointer;
        margin-bottom: 0.5rem;
        transition: background 0.2s, transform 0.2s;
    }
    .camera-btn:hover {
        background: var(--accent-hover);
        color: #fffbe0;
        transform: scale(1.08);
    }
    .gallery {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 1.5rem;
        justify-content: center;
        width: 100%;
        padding: 0;
    }
    .gallery img {
        width: 140px;
        height: 105px;
        object-fit: cover;
        border-radius: 10px;
        border: 1.5px solid var(--border-color);
        background: #222;
        box-shadow: 0 2px 8px rgba(204,188,252,0.07);
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        touch-action: manipulation;
    }
    .gallery img:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 16px rgba(204,188,252,0.15);
    }
    .modal-image {
        max-width: 100%;
        max-height: 60vh;
        border-radius: 12px;
        border: 2px solid var(--border-color);
        box-shadow: 0 4px 24px rgba(204,188,252,0.13);
    }
    .modal-download-btn {
        background: linear-gradient(90deg, #28a745 60%, #218838 100%) !important;
        color: white !important;
        font-weight: 600 !important;
        padding: 12px 24px !important;
        border-radius: 8px !important;
        font-size: 16px !important;
        min-width: 120px !important;
        transition: background 0.18s, transform 0.12s, box-shadow 0.18s !important;
    }
    .modal-download-btn:hover, .modal-download-btn:focus {
        background: linear-gradient(90deg, #34ce57 60%, #28a745 100%) !important;
        transform: translateY(-1px) scale(1.03) !important;
        box-shadow: 0 4px 16px rgba(40, 167, 69, 0.3) !important;
    }
    .realities-title {
        font-size: 2.1rem;
        font-weight: 700;
        margin-bottom: 0.7rem;
        margin-top: 18px;
        background: linear-gradient(45deg, var(--accent-purple), #fff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-align: center;
        max-width: 100vw;
        margin-left: auto;
        margin-right: auto;
        word-break: break-word;
        transition: opacity 0.5s;
    }
    .realities-subtitle {
        font-size: 1.05rem;
        color: var(--text-accent);
        margin-bottom: 1.2rem;
        text-align: center;
        max-width: 100vw;
        margin-left: auto;
        margin-right: auto;
        word-break: break-word;
        transition: opacity 0.5s;
    }
    @media (max-width: 600px) {
        .realities-main {
            justify-content: flex-start !important;
            padding: 20px 8px 40px 8px;
            min-height: 100vh !important;
            height: auto !important;
        }
        
        .realities-title {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            margin-top: 0;
        }
        
        .camera-card {
            width: calc(100vw - 16px);
            max-width: calc(100vw - 16px);
            margin-bottom: 1rem;
            padding: 12px 12px 8px 12px;
        }
        
        .viewfinder {
            width: calc(100vw - 40px);
            max-width: calc(100vw - 40px);
            height: calc((100vw - 40px) * 0.75);
            max-height: 60vh;
            margin-bottom: 0.75rem;
        }
        
        .camera-btn {
            min-width: 56px;
            min-height: 56px;
            font-size: 1.8rem;
            margin-bottom: 0.25rem;
        }
        
        .gallery {
            margin-top: 1rem;
            gap: 12px;
            padding: 0 4px;
        }
        
        .gallery img {
            width: calc((100vw - 44px) / 2);
            height: calc(((100vw - 44px) / 2) * 0.75);
            min-width: 120px;
            min-height: 90px;
        }
    }
    
    @media (max-width: 600px) and (orientation: portrait) {
        body {
            overflow-x: hidden;
            overflow-y: auto !important;
            height: auto !important;
        }
        
        .realities-main {
            align-items: stretch !important;
            justify-content: flex-start !important;
            padding: 15px 8px 60px 8px;
            min-height: 100vh !important;
            height: auto !important;
        }
        
        .camera-card {
            align-self: center;
            width: calc(100vw - 16px);
        }
        
        .gallery {
            width: 100%;
            max-width: 100vw;
            overflow: visible;
            gap: 6px !important;
            padding: 0 !important;
            justify-content: center !important;
            align-items: center !important;
        }
        
        .gallery img {
            width: calc((100vw - 28px) / 3) !important;
            height: calc(((100vw - 28px) / 3) * 0.75) !important;
            min-width: 75px !important;
            min-height: 56px !important;
            max-width: 105px !important;
            max-height: 78px !important;
        }
        
        .modal-image {
            max-width: 90vw;
            max-height: 50vh;
        }
    }
    
    @media (max-width: 400px) {
        .realities-title {
            font-size: 1.6rem;
        }
        
        .camera-card {
            padding: 8px 8px 6px 8px;
        }
        
        .viewfinder {
            border-radius: 12px;
            margin-bottom: 0.5rem;
        }
        
        .camera-btn {
            min-width: 48px;
            min-height: 48px;
            font-size: 1.6rem;
        }
        
        .gallery img {
            width: calc((100vw - 40px) / 2);
            height: calc(((100vw - 40px) / 2) * 0.75);
            min-width: 100px;
            min-height: 75px;
            border-radius: 8px;
        }
        
        .gallery {
            gap: 8px;
            padding: 0 2px;
        }
    }
    </style>
</head>
<body>
    <div class="background-animation" id="backgroundAnimation"></div>
    <div class="realities-main">
        <div class="realities-title">Realities</div>
        <div class="camera-card">
            <div class="viewfinder">
                <video id="camera" width="560" height="420" autoplay playsinline style="display:none;"></video>
                <canvas id="viewfinderCanvas" width="560" height="420" style="display:block;"></canvas>
                <canvas id="canvas" width="560" height="420" style="display:none;"></canvas>
            </div>
            <div style="display: flex; gap: 28px; align-items: center;">
                <button class="camera-btn" id="switchCameraBtn" title="Switch Camera" style="font-size: 1.6rem; min-width: 48px; min-height: 48px;">⟲</button>
                <button class="camera-btn" id="snapBtn" title="Capture Reality" style="margin-left: 0; margin-right: 0;">◉</button>
                <button class="camera-btn" id="importBtn" title="Import Image" style="font-size: 1.6rem; min-width: 48px; min-height: 48px;">＋</button>
                <input type="file" id="importInput" accept="image/*" style="display:none;" />
            </div>
        </div>
        <div class="gallery" id="gallery"></div>
    </div>
    <script src="../modals.js"></script>
    <script src="../stars.js"></script>
    <script>
    // Import button logic
    const importBtn = document.getElementById('importBtn');
    const importInput = document.getElementById('importInput');

    importBtn.onclick = function() {
        importInput.value = '';
        importInput.click();
    };

    importInput.onchange = function(e) {
        if (!importInput.files || !importInput.files[0]) return;
        const file = importInput.files[0];
        const reader = new FileReader();
        reader.onload = function(ev) {
            const img = new window.Image();
            img.onload = function() {
                // Crop to 560x420 aspect ratio, centered
                const aspectW = 560, aspectH = 420;
                let sx = 0, sy = 0, sw = img.width, sh = img.height;
                const srcAspect = img.width / img.height;
                const targetAspect = aspectW / aspectH;
                if (srcAspect > targetAspect) {
                    // Image is wider than target: crop sides
                    sw = img.height * targetAspect;
                    sx = (img.width - sw) / 2;
                } else if (srcAspect < targetAspect) {
                    // Image is taller than target: crop top/bottom
                    sh = img.width / targetAspect;
                    sy = (img.height - sh) / 2;
                }
                // Draw cropped and resized image to tempCanvas
                tempCtx.clearRect(0, 0, 560, 420);
                tempCtx.drawImage(img, sx, sy, sw, sh, 0, 0, 560, 420);
                // Get image data
                const imgData = tempCtx.getImageData(0, 0, 560, 420);
                const data = imgData.data;
                // Use the same effects pipeline as viewfinder
                // Generate palette
                const palette = getPaletteOptimized(data);
                // Quantize
                quantizeOptimized(data, palette, frameCounter++);
                // Put processed image back
                tempCtx.putImageData(imgData, 0, 0);
                // Now compress to 69 colors and add to gallery (like capture)
                const dataCopy = new Uint8ClampedArray(imgData.data);
                const palette69 = generate69ColorPalette(dataCopy);
                quantizeTo69Colors(dataCopy, palette69);
                const compressedCanvas = document.createElement('canvas');
                compressedCanvas.width = 560;
                compressedCanvas.height = 420;
                const compressedCtx = compressedCanvas.getContext('2d');
                const newImgData = new ImageData(dataCopy, 560, 420);
                compressedCtx.putImageData(newImgData, 0, 0);
                const dataUrl = compressedCanvas.toDataURL('image/jpeg', 0.420);
                const galleryImg = document.createElement('img');
                galleryImg.src = dataUrl;
                galleryImg.width = 560;
                galleryImg.height = 420;
                galleryImg.addEventListener('click', function() {
                    openImageModal(dataUrl);
                });
                gallery.prepend(galleryImg);
            };
            img.onerror = function() {
                alert('Could not load image.');
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    };
    // Camera setup
    const video = document.getElementById('camera');
    const viewfinderCanvas = document.getElementById('viewfinderCanvas');
    const viewfinderCtx = viewfinderCanvas.getContext('2d');
    const canvas = document.getElementById('canvas');
    const snapBtn = document.getElementById('snapBtn');
    const switchCameraBtn = document.getElementById('switchCameraBtn');
    const gallery = document.getElementById('gallery');
    let stream = null;
    let currentFacingMode = 'environment'; // Start with rear camera (better for most use cases)
    let availableCameras = [];

    // Pre-allocated resources for performance
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 560;
    tempCanvas.height = 420;
    const tempCtx = tempCanvas.getContext('2d');
    let cachedImageData = tempCtx.createImageData(560, 420);
    let paletteCache = null;
    let paletteCacheFrame = -1;
    const PALETTE_CACHE_FRAMES = 3; // Regenerate palette every N frames

    // Frame persistence for ghosting effect
    const previousFrameCanvas = document.createElement('canvas');
    previousFrameCanvas.width = 560;
    previousFrameCanvas.height = 420;
    const previousFrameCtx = previousFrameCanvas.getContext('2d');
    let hasPreviousFrame = false;

    // Pre-computed lookup tables for performance
    const SAMPLE_INDICES = new Uint32Array(32); // Pre-computed random indices
    const TEMP_PIXELS = new Array(64); // Reusable pixel array
    const TEMP_CENTROIDS = new Array(32); // Reusable centroids array
    const TEMP_CLUSTERS = new Array(32); // Reusable clusters array
    for (let i = 0; i < 32; i++) {
        TEMP_CLUSTERS[i] = [];
        TEMP_CENTROIDS[i] = [0, 0, 0];
    }

    // Pre-compute sample indices for palette generation
    function precomputeSampleIndices() {
        const totalPixels = 560 * 420;
        for (let i = 0; i < 32; i++) {
            SAMPLE_INDICES[i] = (Math.floor(Math.random() * totalPixels) * 4) | 0;
        }
    }
    precomputeSampleIndices();

    async function startCamera() {
        try {
            // Stop existing stream if any
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            // Get available cameras on first load
            if (availableCameras.length === 0) {
                await getAvailableCameras();
            }
            
            const constraints = {
                video: {
                    width: 560,
                    height: 420,
                    facingMode: currentFacingMode
                }
            };
            
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            
            // Show/hide camera switch button based on available cameras
            switchCameraBtn.style.display = availableCameras.length > 1 ? 'block' : 'none';
            
        } catch (e) {
            console.warn('Could not access camera with facingMode:', currentFacingMode);
            // Fallback: try without facingMode constraint
            try {
                const fallbackConstraints = { video: { width: 560, height: 420 } };
                stream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
                video.srcObject = stream;
                switchCameraBtn.style.display = 'none'; // Hide switch button on fallback
            } catch (fallbackError) {
                alert('Could not access camera: ' + fallbackError.message);
            }
        }
    }

    // Get list of available cameras
    async function getAvailableCameras() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableCameras = devices.filter(device => device.kind === 'videoinput');
        } catch (e) {
            console.warn('Could not enumerate devices:', e);
            availableCameras = [];
        }
    }

    // Switch between front and rear cameras
    async function switchCamera() {
        if (availableCameras.length <= 1) return;
        
        // Toggle between front and rear cameras
        currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
        
        // Restart camera with new facing mode
        await startCamera();
    }
    startCamera();

    // Optimized palette generation with caching and minimal allocations
    function getPaletteOptimized(data) {
        // Clear temp arrays without reallocation
        for (let i = 0; i < 32; i++) TEMP_CLUSTERS[i].length = 0;
        
        // Sample pixels using pre-computed indices
        let pixelCount = 0;
        for (let i = 0; i < 32 && pixelCount < 32; i++) {
            const idx = SAMPLE_INDICES[i];
            if (idx < data.length - 2) {
                TEMP_PIXELS[pixelCount] = [data[idx], data[idx + 1], data[idx + 2]];
                pixelCount++;
            }
        }
        
        // Initialize centroids from random pixels
        for (let i = 0; i < 16; i++) {
            const p = TEMP_PIXELS[Math.floor(Math.random() * pixelCount)];
            TEMP_CENTROIDS[i][0] = p[0];
            TEMP_CENTROIDS[i][1] = p[1];
            TEMP_CENTROIDS[i][2] = p[2];
        }
        
        // Single K-means iteration
        for (let i = 0; i < pixelCount; i++) {
            const p = TEMP_PIXELS[i];
            let minDist = 999999, idx = 0;
            for (let j = 0; j < 16; j++) {
                const c = TEMP_CENTROIDS[j];
                const d = (p[0] - c[0]) * (p[0] - c[0]) + 
                         (p[1] - c[1]) * (p[1] - c[1]) + 
                         (p[2] - c[2]) * (p[2] - c[2]);
                if (d < minDist) { minDist = d; idx = j; }
            }
            TEMP_CLUSTERS[idx].push(p);
        }
        
        // Update centroids
        const result = new Array(16);
        for (let i = 0; i < 16; i++) {
            if (TEMP_CLUSTERS[i].length > 0) {
                let r = 0, g = 0, b = 0;
                for (const p of TEMP_CLUSTERS[i]) {
                    r += p[0]; g += p[1]; b += p[2];
                }
                const len = TEMP_CLUSTERS[i].length;
                result[i] = [(r / len) | 0, (g / len) | 0, (b / len) | 0];
            } else {
                result[i] = [TEMP_CENTROIDS[i][0], TEMP_CENTROIDS[i][1], TEMP_CENTROIDS[i][2]];
            }
        }
        return result;
    }

    // Ultra-optimized dithering with pre-computed distances
    function quantizeOptimized(data, palette, frameCounter) {
        const w = 560, h = 420;
        const cbOffset = frameCounter & 1; // Faster than Math.floor(Math.random() * 2)
        const glitchMask = ((frameCounter % 3) + 2) | 0;
        
        // Process 4 pixels at once when possible for better cache usage
        for (let y = 0; y < h; y++) {
            const yOffset = y * w * 4;
            for (let x = 0; x < w; x++) {
                const i = yOffset + x * 4;
                const r = data[i], g = data[i + 1], b = data[i + 2];
                
                // Find two closest colors using unrolled loop for small palette
                let minDist = 999999, minDist2 = 999999;
                let idx = 0, idx2 = 0;
                
                for (let j = 0; j < palette.length; j++) {
                    const p = palette[j];
                    const dist = (r - p[0]) * (r - p[0]) + 
                               (g - p[1]) * (g - p[1]) + 
                               (b - p[2]) * (b - p[2]);
                    if (dist < minDist) {
                        minDist2 = minDist; idx2 = idx;
                        minDist = dist; idx = j;
                    } else if (dist < minDist2) {
                        minDist2 = dist; idx2 = j;
                    }
                }
                
                // Fast dithering decision
                let useSecond = ((x + y + cbOffset) & 1) === 0;
                if (((x ^ y ^ frameCounter) % glitchMask) === 0) useSecond = !useSecond;
                
                const color = palette[useSecond ? idx2 : idx];
                data[i] = color[0];
                data[i + 1] = color[1];
                data[i + 2] = color[2];
            }
        }
    }

    // State tracking
    let frameCounter = 0;

    // Optimized render pipeline
    function processFrame() {
        if (!stream || video.readyState < 2) return;
        
        frameCounter++;
        
        // Draw video directly to temp canvas
        tempCtx.drawImage(video, 0, 0, 560, 420);
        
        // Get image data once
        const imgData = tempCtx.getImageData(0, 0, 560, 420);
        const data = imgData.data;
        
        // Use cached palette or generate new one
        if (!paletteCache || (frameCounter - paletteCacheFrame) >= PALETTE_CACHE_FRAMES) {
            paletteCache = getPaletteOptimized(data);
            paletteCacheFrame = frameCounter;
            // Update sample indices occasionally for variation
            if (frameCounter % 10 === 0) precomputeSampleIndices();
        }
        
        // Apply optimized quantization directly to image data
        quantizeOptimized(data, paletteCache, frameCounter);
        
        // Draw processed image to viewfinder
        viewfinderCtx.putImageData(imgData, 0, 0);
        
        // Blend previous frame on top at 33% opacity if we have one
        if (hasPreviousFrame) {
            viewfinderCtx.globalAlpha = 0.33;
            viewfinderCtx.drawImage(previousFrameCanvas, 0, 0);
            viewfinderCtx.globalAlpha = 1.0; // Reset alpha
        }
        
        // Save current frame for next iteration
        previousFrameCtx.clearRect(0, 0, 560, 420);
        previousFrameCtx.drawImage(viewfinderCanvas, 0, 0);
        hasPreviousFrame = true;
    }

    // Use requestAnimationFrame for smoother performance, capped at ~15fps
    let lastFrameTime = 0;
    const targetFrameTime = 1000 / 15; // ~15fps
    
    function renderLoop(currentTime) {
        if (currentTime - lastFrameTime >= targetFrameTime) {
            processFrame();
            lastFrameTime = currentTime;
        }
        requestAnimationFrame(renderLoop);
    }
    requestAnimationFrame(renderLoop);

    // Snap button: capture single frame and compress to 69 colors
    snapBtn.onclick = function() {
        if (snapBtn.disabled) return;
        
        snapBtn.disabled = true;
        snapBtn.textContent = '⧗';
        snapBtn.style.opacity = '0.6';
        
        // Small delay to show the processing state
        setTimeout(() => {
            captureAndCompressFrame();
        }, 100);
    };

    // Camera switch button
    switchCameraBtn.onclick = function() {
        if (switchCameraBtn.disabled) return;
        
        switchCameraBtn.disabled = true;
        switchCameraBtn.style.opacity = '0.6';
        
        switchCamera().then(() => {
            switchCameraBtn.disabled = false;
            switchCameraBtn.style.opacity = '1';
        }).catch((e) => {
            console.error('Camera switch error:', e);
            switchCameraBtn.disabled = false;
            switchCameraBtn.style.opacity = '1';
        });
    };

    // Capture current frame and compress to exactly 69 colors
    function captureAndCompressFrame() {
        try {
            // Get current viewfinder image data
            const imgData = viewfinderCtx.getImageData(0, 0, 560, 420);
            const data = new Uint8ClampedArray(imgData.data);
            
            // Generate a palette with exactly 69 colors
            const palette69 = generate69ColorPalette(data);
            
            // Quantize the image to use only these 69 colors
            quantizeTo69Colors(data, palette69);
            
            // Create a new canvas with the quantized image
            const compressedCanvas = document.createElement('canvas');
            compressedCanvas.width = 560;
            compressedCanvas.height = 420;
            const compressedCtx = compressedCanvas.getContext('2d');
            
            // Put the quantized image data
            const newImgData = new ImageData(data, 560, 420);
            compressedCtx.putImageData(newImgData, 0, 0);
            
            // Convert to data URL with high compression for limited colors
            // Use lower quality JPEG for smaller file size, then convert back to maintain the quantized look
            const dataUrl = compressedCanvas.toDataURL('image/jpeg', 0.420); // 70% quality for smaller size
            
            // Create image element for gallery
            const img = document.createElement('img');
            img.src = dataUrl;
            img.width = 560;
            img.height = 420;
            
            // Add click handler to open in modal
            img.addEventListener('click', function() {
                openImageModal(dataUrl);
            });
            
            gallery.prepend(img);
            
            // Reset button
            snapBtn.disabled = false;
            snapBtn.textContent = '◉';
            snapBtn.style.opacity = '1';
            
        } catch (error) {
            console.error('Capture error:', error);
            // Reset button on error
            snapBtn.disabled = false;
            snapBtn.textContent = '◉';
            snapBtn.style.opacity = '1';
        }
    }

    // Generate exactly 69 colors using k-means clustering
    function generate69ColorPalette(data) {
        const numColors = 69;
        const sampleSize = Math.min(420, data.length / 4); // Sample 420 pixels for clustering
        const samples = [];
        
        // Sample pixels randomly
        for (let i = 0; i < sampleSize; i++) {
            const idx = Math.floor(Math.random() * (data.length / 4)) * 4;
            samples.push([data[idx], data[idx + 1], data[idx + 2]]);
        }
        
        // Initialize centroids randomly
        const centroids = [];
        for (let i = 0; i < numColors; i++) {
            const sample = samples[Math.floor(Math.random() * samples.length)];
            centroids.push([sample[0], sample[1], sample[2]]);
        }
        
        // K-means clustering iterations
        for (let iter = 0; iter < 5; iter++) {
            const clusters = Array(numColors).fill().map(() => []);
            
            // Assign pixels to closest centroid
            for (const pixel of samples) {
                let minDist = Infinity;
                let closestIdx = 0;
                
                for (let i = 0; i < numColors; i++) {
                    const dist = Math.pow(pixel[0] - centroids[i][0], 2) +
                                 Math.pow(pixel[1] - centroids[i][1], 2) +
                                 Math.pow(pixel[2] - centroids[i][2], 2);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = i;
                    }
                }
                clusters[closestIdx].push(pixel);
            }
            
            // Update centroids
            for (let i = 0; i < numColors; i++) {
                if (clusters[i].length > 0) {
                    let r = 0, g = 0, b = 0;
                    for (const pixel of clusters[i]) {
                        r += pixel[0];
                        g += pixel[1];
                        b += pixel[2];
                    }
                    centroids[i] = [
                        Math.round(r / clusters[i].length),
                        Math.round(g / clusters[i].length),
                        Math.round(b / clusters[i].length)
                    ];
                }
            }
        }
        
        return centroids;
    }

    // Quantize image data to use only the 69-color palette
    function quantizeTo69Colors(data, palette) {
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Find closest color in palette
            let minDist = Infinity;
            let closestColor = palette[0];
            
            for (const color of palette) {
                const dist = Math.pow(r - color[0], 2) +
                            Math.pow(g - color[1], 2) +
                            Math.pow(b - color[2], 2);
                if (dist < minDist) {
                    minDist = dist;
                    closestColor = color;
                }
            }
            
            data[i] = closestColor[0];
            data[i + 1] = closestColor[1];
            data[i + 2] = closestColor[2];
        }
    }

    // Function to open image in modal with download button
    function openImageModal(imageUrl) {
        const modalImage = document.createElement('img');
        modalImage.src = imageUrl;
        modalImage.className = 'modal-image';
        modalImage.alt = 'Captured Reality';

        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = '⬇ Download Image';
        downloadBtn.className = 'modal-download-btn';
        downloadBtn.onclick = function() {
            downloadImage(imageUrl);
        };

        const content = document.createElement('div');
        content.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 20px;';
        content.appendChild(modalImage);
        content.appendChild(downloadBtn);

        Modals.open({
            title: 'Captured Reality',
            content: content,
            confirmText: 'Close',
            showCancel: false,
            closeOnOverlay: true
        });
    }

    // Function to download image
    function downloadImage(dataUrl) {
        const link = document.createElement('a');
        link.download = `reality-${Date.now()}.jpg`;
        link.href = dataUrl;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    </script>
</body>
</html>

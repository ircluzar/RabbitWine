<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit Wine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="objects.css">
</head>
<body>
    <button class="mute-button" id="muteButton" title="Toggle Music">ðŸ”Š</button>
    <div class="container">
        <div class="stats-panel panel">
            <div class="credit-display">
                <div class="credit-amount" id="creditAmount">0</div>
                <div class="credit-label">Credits</div>
                <div class="object-level" id="objectLevel">Level 1</div>
            </div>
            <button class="button-base upgrade-button" id="upgradeButton" style="display: none;">Upgrade - 300</button>
            <button class="button-base refresh-button" id="refreshButton" style="display: none;">Refresh Cooldown</button>
            <button class="button-base subtick-button" id="subtickButton" style="display: none;">Charge Subtick</button>
            <div class="subtick-meter" id="subtickMeter" style="display: none;">Subticks: 0</div>
        </div>
        <div class="objects-panel panel">
            <div class="section-header">
                <div class="section-title">Object</div>
                <button class="discard-button" id="discardButton" style="display: none;">Discard Object</button>
            </div>
            <div class="objects-grid" id="objectsGrid"></div>
        </div>
    </div>
    <div class="feedback" id="feedback"></div>
    <style>
        .tier-transition {
            position: relative;
            overflow: hidden;
        }
        
        .tier-transition::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            opacity: 0;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        
        .tier-transition.flashing::before {
            opacity: 1;
        }
        
        .tier-transition.revealing::before {
            opacity: 0;
            transition: opacity 2s ease-out;
        }
    </style>
    <script>
        $(document).ready(function() {
            const CACHE_KEY = 'rabbitobjects_save', MAX_OBJECTS = 4000;
            let state = { credits: 0, objects: [createEmptyObject()], isMuted: false };
            let currentMusicAudio = null, cooldownIntervals = new Map();
            
            function formatNumber(num) {
                if (num < 1000) return num.toString();
                
                const units = [
                    { value: 1e24, symbol: 'Y' },  // Yotta
                    { value: 1e21, symbol: 'Z' },  // Zetta
                    { value: 1e18, symbol: 'E' },  // Exa
                    { value: 1e15, symbol: 'P' },  // Peta
                    { value: 1e12, symbol: 'T' },  // Tera
                    { value: 1e9,  symbol: 'G' },  // Giga
                    { value: 1e6,  symbol: 'M' },  // Mega
                    { value: 1e3,  symbol: 'K' }   // Kilo
                ];
                
                for (const unit of units) {
                    if (num >= unit.value) {
                        const formatted = (num / unit.value).toFixed(1);
                        // Remove trailing .0 if it exists
                        return formatted.replace(/\.0$/, '') + unit.symbol;
                    }
                }
                
                return num.toString();
            }
            
            function createEmptyObject() {
                return { 
                    id: 'master', 
                    isEmpty: true, 
                    imageNumber: null, 
                    level: 1, 
                    baseCost: 300, 
                    costScaling: 1.5, 
                    tickValue: null, 
                    breakProbability: null, 
                    shatterBonus: null, 
                    music: null, 
                    breakSfx: null, 
                    cooldown: null, 
                    lastTicked: null, 
                    currentMusic: null, 
                    subtickCount: 0 
                };
            }
            
            function getObjectTier(level) {
				if (level >= 100) return 'realities';
                if (level >= 50) return 'places';
                if (level >= 20) return 'orbs';
                return 'shapes';
            }
            
            function getImagePath(obj) {
                const tier = getObjectTier(obj.level);
                let imageNum = obj.imageNumber;
                
                if (tier === 'orbs') {
                    imageNum = Math.floor(obj.imageNumber / 4);
                } else if (tier === 'places') {
                    imageNum = Math.floor(obj.imageNumber / 40);
                } else if (tier === 'realities') {
                    imageNum = Math.floor(obj.imageNumber / 100);
                }
                
                return `${tier}/${imageNum}.gif`;
            }
            
            function validateSave(saved) {
                try {
                    if (!saved?.objects?.[0] || typeof saved.credits !== 'number' || saved.credits < 0) return false;
                    const obj = saved.objects[0];
                    if (typeof obj.subtickCount !== 'number') obj.subtickCount = 0;
                    if (typeof obj.currentMusic !== 'boolean') obj.currentMusic = false;
                    return true;
                } catch (e) { return false; }
            }
            
            function saveGame() { try { localStorage.setItem(CACHE_KEY, JSON.stringify(state)); } catch(e) {} }
            function loadGame() { try { const saved = JSON.parse(localStorage.getItem(CACHE_KEY)); return validateSave(saved) ? saved : null; } catch(e) { return null; } }
            
            function playAudio(folder, num, vol, isWav, loop = false) {
                if (state.isMuted) return;
                const audio = new Audio(`${folder}/${num}.${isWav ? 'wav' : 'mp3'}`);
                audio.volume = vol; audio.loop = loop;
                audio.play().catch(() => {});
                return audio;
            }
            
            function playMusic(num) { if (currentMusicAudio) currentMusicAudio.pause(); currentMusicAudio = playAudio('corridor', num, 0.15, false, true); }
            function playBreakSfx(num) { playAudio('break', num, 0.25, true); }
            function playTickSfx(num) { playAudio('tick', num, 0.2, false); }
            function playPopSfx() { playAudio('pop', Math.floor(Math.random() * 10) + 1, 0.69, true); }
            function stopMusic() { if (currentMusicAudio) { currentMusicAudio.pause(); currentMusicAudio = null; } }
            
            function toggleMute() {
                state.isMuted = !state.isMuted;
                const $btn = $('#muteButton');
                if (state.isMuted) { stopMusic(); $btn.text('ðŸ”‡').addClass('muted'); }
                else { $btn.text('ðŸ”Š').removeClass('muted'); const obj = state.objects[0]; if (!obj.isEmpty && obj.currentMusic) playMusic(obj.music); }
                saveGame();
            }
            
            function generateObj() {
                return {
                    imageNumber: Math.floor(Math.random() * MAX_OBJECTS), level: 1, baseCost: 300, costScaling: 1.3 + Math.random() * 0.69,
                    tickValue: Math.floor(Math.random() * 11) + 4, breakProbability: Math.floor(Math.random() * 35) + 16,
                    shatterBonus: Math.floor(Math.random() * 420) + 69, music: Math.floor(Math.random() * 39) + 1,
                    breakSfx: Math.floor(Math.random() * 18) + 1, cooldown: Math.floor(Math.random() * 20) + 1,
                    lastTicked: null, currentMusic: false, subtickCount: 0
                };
            }
            
            function getCost(obj, type) {
                const base = type === 'upgrade' ? Math.floor(obj.baseCost * Math.pow(obj.costScaling, obj.level - 1)) : state.credits;
                return type === 'upgrade' ? base : Math.floor(base * (type === 'refresh' ? 10 + obj.level : 15 + obj.level) / 100);
            }
            
            function performTierTransition(obj, $slot) {
                const $img = $slot.find('.object-image');
                const newImagePath = getImagePath(obj);
                
                // Add transition class and trigger flash
                $slot.addClass('tier-transition flashing');
                
                // Change music
                obj.music = Math.floor(Math.random() * 39) + 1;
                if (obj.currentMusic && !state.isMuted) {
                    stopMusic();
                    playMusic(obj.music);
                }
                
                setTimeout(() => {
                    // Load new image
                    $img.attr('src', newImagePath);
                    
                    // Start reveal transition
                    $slot.removeClass('flashing').addClass('revealing');
                    
                    setTimeout(() => {
                        $slot.removeClass('tier-transition revealing');
                    }, 2000);
                }, 300);
            }
            
            function upgradeObject() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                const cost = getCost(obj, 'upgrade');
                if (state.credits < cost) return;
                
                playPopSfx();
                state.credits -= cost;
                
                const previousTier = getObjectTier(obj.level);
                obj.level++;
                const newTier = getObjectTier(obj.level);
                
                const upgrades = [
                    () => { obj.tickValue = Math.max(2, Math.floor(obj.tickValue * 2.69)) + 25; return 'Tick value increased!'; },
                    () => { obj.breakProbability = Math.max(5, obj.breakProbability - 4); return 'Break chance reduced!'; },
                    () => { obj.shatterBonus = Math.floor(obj.shatterBonus * 2.69); return 'Shatter bonus increased!'; },
                    () => { obj.cooldown = Math.max(2, obj.cooldown - 2); return 'Cooldown reduced!'; }
                ];
                
                let feedbackMessage = upgrades[Math.floor(Math.random() * 4)]();
                
                // Check for tier transition
                if (previousTier !== newTier) {
                    const $slot = $(`.object-slot[data-index="0"]`);
                    if ($slot.length) {
                        performTierTransition(obj, $slot);
                    }
                    
                    if (newTier === 'orbs') {
                        feedbackMessage = 'Tier upgrade: Shape â†’ Orb!';
                    } else if (newTier === 'places') {
                        feedbackMessage = 'Tier upgrade: Orb â†’ Place!';
                    }
                }
                
                showFeedback(feedbackMessage, 'success');
                saveGame(); updateUI();
            }
            
            function refreshCooldown() {
                const obj = state.objects[0];
                if (obj.isEmpty || !isOnCooldown(0)) return;
                const cost = getCost(obj, 'refresh');
                if (state.credits < cost) return;
                
                playPopSfx();
                state.credits -= cost; obj.lastTicked = null;
                clearCooldown(0); updateCooldownDisplay(0);
                showFeedback('Cooldown refreshed!', 'success');
                saveGame(); updateUI();
            }
            
            function chargeSubtick() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                const cost = getCost(obj, 'subtick');
                if (state.credits < cost || cost <= 0) return;
                
                playPopSfx();
                state.credits -= cost; obj.subtickCount++;
                showFeedback('Subtick charged!', 'success');
                saveGame(); updateUI();
            }
            
            function resetObject(obj) {
                Object.assign(obj, createEmptyObject());
            }
            
            function discardObject() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                if (obj.currentMusic) stopMusic();
                clearCooldown(0); playBreakSfx(obj.breakSfx);
                resetObject(obj);
                saveGame(); updateUI(); showFeedback('Object discarded!', 'warning');
            }
            
            function isOnCooldown(idx) {
                const obj = state.objects[idx];
                return obj.lastTicked && (Date.now() - obj.lastTicked) < (obj.cooldown * 1000);
            }
            
            function getCooldownRemaining(idx) {
                const obj = state.objects[idx];
                if (!obj.lastTicked) return 0;
                return Math.max(0, (obj.cooldown * 1000) - (Date.now() - obj.lastTicked));
            }
            
            function clearCooldown(idx) {
                if (cooldownIntervals.has(idx)) { clearInterval(cooldownIntervals.get(idx)); cooldownIntervals.delete(idx); }
            }
            
            function startCooldownTimer(idx) {
                const obj = state.objects[idx];
                if (obj.isEmpty) return;
                clearCooldown(idx);
                const interval = setInterval(() => {
                    if (isOnCooldown(idx)) updateCooldownDisplay(idx);
                    else { clearCooldown(idx); updateCooldownDisplay(idx); }
                }, 100);
                cooldownIntervals.set(idx, interval);
            }
            
            function updateCooldownDisplay(idx) {
                const $slot = $(`.object-slot[data-index="${idx}"]`);
                const remaining = getCooldownRemaining(idx);
                
                if (remaining > 0) {
                    const obj = state.objects[idx];
                    const progress = ((obj.cooldown * 1000 - remaining) / (obj.cooldown * 1000)) * 100;
                    $slot.addClass('cooldown').find('.cooldown-bar').css('width', `${progress}%`);
                    $slot.find('.cooldown-text').text(`${Math.ceil(remaining / 1000)}s`).show();
                } else {
                    $slot.removeClass('cooldown').find('.cooldown-bar').css('width', '0%');
                    $slot.find('.cooldown-text').hide();
                }
            }
            
            function tickObject(idx) {
                const obj = state.objects[idx];
                if (obj.isEmpty || isOnCooldown(idx)) return;
                
                // Process subticks (give credits, no break risk, no SFX)
                if (obj.subtickCount > 0) {
                    const subtickCredits = obj.tickValue * obj.subtickCount;
                    state.credits += subtickCredits;
                    showFeedback(`${obj.subtickCount} subticks: +${formatNumber(subtickCredits)}!`, 'success');
                    obj.subtickCount = 0;
                }
                
                // Main tick
                state.credits += obj.tickValue;
                showFeedback(`+${formatNumber(obj.tickValue)}!`, 'success');
                obj.lastTicked = Date.now();
                startCooldownTimer(idx);
                
                // Check for break
                if (Math.random() * 100 < obj.breakProbability) {
                    state.credits += obj.shatterBonus;
                    showFeedback(`Object shattered! +${formatNumber(obj.shatterBonus)} bonus!`, 'warning');
                    playBreakSfx(obj.breakSfx);
                    if (obj.currentMusic) stopMusic();
                    clearCooldown(idx);
                    resetObject(obj);
                } else {
                    playTickSfx((obj.breakSfx % 3) + 1);
                }
                saveGame(); updateUI();
            }
            
            function fillEmptySlot(idx) {
                const obj = state.objects[idx];
                if (!obj.isEmpty) return;
                
                const newObj = generateObj();
                Object.assign(obj, newObj);
                obj.isEmpty = false; obj.currentMusic = true;
                
                // Bonus scaling
                const cooldownBonuses = [5, 15, 25, 35, 45];
                const breakBonuses = [20, 30, 40];
                cooldownBonuses.forEach(threshold => { if (obj.cooldown > threshold) obj.tickValue *= 2; });
                breakBonuses.forEach(threshold => { if (obj.breakProbability > threshold) obj.tickValue *= 2; });
                
                stopMusic(); playMusic(obj.music);
                saveGame(); updateUI(); showFeedback('New object', 'success');
            }
            
            function showFeedback(msg, type = 'success') {
                const $fb = $('#feedback');
                $fb.removeClass('success warning error').addClass(type).text(msg).addClass('show');
                setTimeout(() => $fb.removeClass('show'), 3000);
            }
            
            function updateUI() {
                $('#creditAmount').text(formatNumber(state.credits));
                const obj = state.objects[0];
                const buttons = { upgrade: $('#upgradeButton'), refresh: $('#refreshButton'), subtick: $('#subtickButton') };
                const $discard = $('#discardButton'), $level = $('#objectLevel'), $meter = $('#subtickMeter');
                
                if (obj.isEmpty) {
                    Object.values(buttons).forEach(btn => btn.hide());
                    $discard.hide(); $meter.hide(); $level.text('Level 1');
                } else {
                    buttons.upgrade.show().text(`Upgrade - ${formatNumber(getCost(obj, 'upgrade'))}`).prop('disabled', state.credits < getCost(obj, 'upgrade'));
                    $discard.show(); $level.text(`Level ${obj.level}`);
                    
                    if (obj.level > 2) {
                        const refreshCost = getCost(obj, 'refresh');
                        buttons.refresh.show().text(`Refresh - ${formatNumber(refreshCost)}`).prop('disabled', state.credits < refreshCost || !isOnCooldown(0));
                    } else buttons.refresh.hide();
                    
                    if (obj.level > 4) {
                        const subtickCost = getCost(obj, 'subtick');
                        buttons.subtick.show().text(`Charge Subtick - ${formatNumber(subtickCost)}`).prop('disabled', state.credits < subtickCost || subtickCost <= 0);
                        $meter.show().text(`Subticks: ${obj.subtickCount}`);
                    } else { buttons.subtick.hide(); $meter.hide(); }
                }
                renderSlots();
            }
            
            function renderSlots() {
                const $grid = $('#objectsGrid');
                $grid.empty();
                
                state.objects.forEach((obj, idx) => {
                    const $slot = $('<div>').addClass('object-slot').attr('data-index', idx);
                    
                    if (obj.isEmpty) {
                        $slot.addClass('empty').html('<div>Click for a new object</div>').on('click', () => fillEmptySlot(idx));
                    } else {
                        $slot.addClass('filled');
                        
                        const imagePath = getImagePath(obj);
                        const $img = $('<img>').addClass('object-image').attr('src', imagePath).attr('alt', `Object ${obj.imageNumber}`)
                            .on('error', function() { $(this).attr('src', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSIjNGE0YTRhIi8+Cjx0ZXh0IHg9IjUwIiB5PSI1NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzk0YTNiOCIgZm9udC1zaXplPSIxMiI+Tm90IEZvdW5kPC90ZXh0Pgo8L3N2Zz4='); });
                        
                        const tier = getObjectTier(obj.level);
                        const tierDisplay = tier.charAt(0).toUpperCase() + tier.slice(1, -1); // "Shape", "Orb", "Place"
                        
                        let stats = `<div class="stat-row"><span class="stat-label">Tier:</span><span class="stat-value">${tierDisplay}</span></div>
                            <div class="stat-row"><span class="stat-label">Level:</span><span class="stat-value">${obj.level}</span></div>
                            <div class="stat-row"><span class="stat-label">Tick:</span><span class="stat-value">${formatNumber(obj.tickValue)}</span></div>
                            <div class="stat-row"><span class="stat-label">Break:</span><span class="stat-value">${obj.breakProbability}%</span></div>
                            <div class="stat-row"><span class="stat-label">Shatter:</span><span class="stat-value">${formatNumber(obj.shatterBonus)}</span></div>
                            <div class="stat-row"><span class="stat-label">Cooldown:</span><span class="stat-value">${obj.cooldown}s</span></div>`;
                        
                        if (obj.subtickCount > 0) stats += `<div class="stat-row"><span class="stat-label">Subticks:</span><span class="stat-value">${obj.subtickCount}</span></div>`;
                        
                        const $stats = $('<div>').addClass('object-stats').html(stats);
                        const $cooldownBar = $('<div>').addClass('cooldown-bar');
                        const $cooldownText = $('<div>').addClass('cooldown-text').hide();
                        
                        $slot.append($img, $stats, $cooldownBar, $cooldownText).on('click', () => {
                            if (!isOnCooldown(idx)) {
                                $slot.addClass('pulsing');
                                setTimeout(() => $slot.removeClass('pulsing'), 500);
                                tickObject(idx);
                            }
                        });
                        
                        updateCooldownDisplay(idx);
                        if (isOnCooldown(idx)) startCooldownTimer(idx);
                    }
                    $grid.append($slot);
                });
            }
            
            function init() {
                const saved = loadGame();
                if (saved) {
                    state = saved;
                    const obj = state.objects[0];
                    if (!obj.isEmpty && obj.currentMusic && !state.isMuted) playMusic(obj.music);
                } else {
                    showFeedback('Save reset - creating new game', 'warning');
                }
                
                const $mute = $('#muteButton');
                $mute.text(state.isMuted ? 'ðŸ”‡' : 'ðŸ”Š')[state.isMuted ? 'addClass' : 'removeClass']('muted');
                
                $mute.on('click', toggleMute);
                $('#upgradeButton').on('click', upgradeObject);
                $('#refreshButton').on('click', refreshCooldown);
                $('#subtickButton').on('click', chargeSubtick);
                $('#discardButton').on('click', discardObject);
                
                updateUI();
                setInterval(saveGame, 5000);
            }
            
            init();
        });
    </script>
</body>
</html>
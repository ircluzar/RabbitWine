<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit Wine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <link rel="stylesheet" href="objects.css">
</head>
<body>
    <button class="mute-button" id="muteButton" title="Toggle Music">ðŸ”Š</button>
    <div class="container">
        <div class="stats-panel panel">
            <div class="credit-display">
                <div class="credit-amount" id="creditAmount">0</div>
                <div class="credit-label">Credits</div>
                <div class="object-level" id="objectLevel">Level 1</div>
            </div>
            <button class="button-base upgrade-button" id="upgradeButton" style="display: none;">Upgrade - 300</button>
            <button class="button-base refresh-button" id="refreshButton" style="display: none;">Refresh Cooldown</button>
            <button class="button-base subtick-button" id="subtickButton" style="display: none;">Charge Subtick</button>
            <div class="subtick-meter" id="subtickMeter" style="display: none;">Subticks: 0</div>
        </div>
        <div class="objects-panel panel">
            <div class="section-header">
                <div class="section-title">Object</div>
                <div class="button-group">
                    <button class="button-base auto-button" id="autoButton" style="display: none;">Auto</button>
                    <button class="button-base discard-button" id="discardButton" style="display: none;"> X </button>
                </div>
            </div>
            <div class="objects-grid" id="objectsGrid"></div>
        </div>
    </div>
    <div class="feedback" id="feedback"></div>
    <script>
        $(document).ready(function() {
            const CACHE_KEY = 'rabbitobjects_save', MAX_OBJECTS = 4000;
            let state = { credits: 0, objects: [createEmptyObject()], isMuted: false };
            let currentMusicAudio = null, cooldownIntervals = new Map();
            let autoClickEnabled = false, isDraining = false, isAutoUpgrading = false;
            let drainInterval = null, autoUpgradeInterval = null, upgradeHoldTimer = null;
            
            const tiers = [
                { min: 0, name: 'shapes', img: n => n },
                { min: 20, name: 'orbs', img: n => Math.floor(n / 4) },
                { min: 50, name: 'places', img: n => Math.floor(n / 40) },
                { min: 100, name: 'realities', img: n => Math.floor(n / 100) }
            ];
            
            const formatUnits = [
                { value: 1e24, symbol: 'Y' }, { value: 1e21, symbol: 'Z' },
                { value: 1e18, symbol: 'E' }, { value: 1e15, symbol: 'P' },
                { value: 1e12, symbol: 'T' }, { value: 1e9, symbol: 'G' },
                { value: 1e6, symbol: 'M' }, { value: 1e3, symbol: 'K' }
            ];
            
            function formatNumber(num) {
                if (num < 1000) return num.toString();
                for (const unit of formatUnits) {
                    if (num >= unit.value) {
                        return (num / unit.value).toFixed(1).replace(/\.0$/, '') + unit.symbol;
                    }
                }
                return num.toString();
            }
            
            function formatDecimal(num, suffix = '') {
                return (num % 1 === 0 ? num.toString() : num.toFixed(2).replace(/\.?0+$/, '')) + suffix;
            }
            
            function createEmptyObject() {
                return { 
                    id: 'master', isEmpty: true, imageNumber: null, level: 1, baseCost: 300, 
                    costScaling: 1.5, tickValue: null, breakProbability: null, shatterBonus: null, 
                    music: null, breakSfx: null, cooldown: null, lastTicked: null, 
                    currentMusic: null, subtickCount: 0 
                };
            }
            
            function getObjectTier(level) {
                for (let i = tiers.length - 1; i >= 0; i--) {
                    if (level >= tiers[i].min) return tiers[i];
                }
                return tiers[0];
            }
            
            function getImagePath(obj) {
                const tier = getObjectTier(obj.level);
                return `${tier.name}/${tier.img(obj.imageNumber)}.gif`;
            }
            
            function validateSave(saved) {
                try {
                    if (!saved?.objects?.[0] || typeof saved.credits !== 'number' || saved.credits < 0) return false;
                    const obj = saved.objects[0];
                    if (typeof obj.subtickCount !== 'number') obj.subtickCount = 0;
                    if (typeof obj.currentMusic !== 'boolean') obj.currentMusic = false;
                    return true;
                } catch (e) { return false; }
            }
            
            function saveGame() { try { localStorage.setItem(CACHE_KEY, JSON.stringify(state)); } catch(e) {} }
            function loadGame() { try { const saved = JSON.parse(localStorage.getItem(CACHE_KEY)); return validateSave(saved) ? saved : null; } catch(e) { return null; } }
            
            function playAudio(folder, num, vol, isWav, loop = false) {
                if (state.isMuted) return;
                const audio = new Audio(`${folder}/${num}.${isWav ? 'wav' : 'mp3'}`);
                audio.volume = vol; audio.loop = loop;
                audio.play().catch(() => {});
                return audio;
            }
            
            function playMusic(num) { 
                if (currentMusicAudio) currentMusicAudio.pause(); 
                currentMusicAudio = playAudio('corridor', num, 0.15, false, true); 
            }
            
            function playBreakSfx(num) { playAudio('break', num, 0.25, true); }
            function playTickSfx(num) { playAudio('tick', num, 0.2, false); }
            function playPopSfx() { playAudio('pop', Math.floor(Math.random() * 10) + 1, 0.69, true); }
            function stopMusic() { if (currentMusicAudio) { currentMusicAudio.pause(); currentMusicAudio = null; } }
            
            function toggleMute() {
                state.isMuted = !state.isMuted;
                const $btn = $('#muteButton');
                if (state.isMuted) { 
                    stopMusic(); 
                    $btn.text('ðŸ”‡').addClass('muted'); 
                } else { 
                    $btn.text('ðŸ”Š').removeClass('muted'); 
                    const obj = state.objects[0]; 
                    if (!obj.isEmpty && obj.currentMusic) playMusic(obj.music); 
                }
                saveGame();
            }
            
            function toggleAuto() {
                autoClickEnabled = !autoClickEnabled;
                $('#autoButton').text('Auto').toggleClass('active', autoClickEnabled);
            }
            
            function stopProcess(type) {
                if (type === 'drain') {
                    if (drainInterval) clearInterval(drainInterval);
                    drainInterval = null; isDraining = false;
                    $('#subtickButton').removeClass('draining');
                } else if (type === 'upgrade') {
                    if (autoUpgradeInterval) clearInterval(autoUpgradeInterval);
                    autoUpgradeInterval = null; isAutoUpgrading = false;
                    $('#upgradeButton').removeClass('auto-upgrading');
                }
                updateUI();
            }
            
            function generateObj() {
                return {
                    imageNumber: Math.floor(Math.random() * MAX_OBJECTS), level: 1, baseCost: 300,
                    costScaling: 1.3 + Math.random() * 0.69, tickValue: Math.floor(Math.random() * 11) + 4,
                    breakProbability: Math.floor(Math.random() * 35) + 16, shatterBonus: Math.floor(Math.random() * 420) + 69,
                    music: Math.floor(Math.random() * 39) + 1, breakSfx: Math.floor(Math.random() * 18) + 1,
                    cooldown: Math.floor(Math.random() * 20) + 1, lastTicked: null, currentMusic: false, subtickCount: 0
                };
            }
            
            function getCost(obj, type) {
                const base = type === 'upgrade' ? Math.floor(obj.baseCost * Math.pow(obj.costScaling, obj.level - 1)) : state.credits;
                return type === 'upgrade' ? base : Math.floor(base * (type === 'refresh' ? 10 + obj.level : 15 + obj.level) / 100);
            }
            
            function performTierTransition(obj, $slot) {
                const $img = $slot.find('.object-image');
                $slot.addClass('tier-transition flashing');
                obj.music = Math.floor(Math.random() * 39) + 1;
                
                if (obj.currentMusic && !state.isMuted) {
                    stopMusic();
                    playMusic(obj.music);
                }
                
                setTimeout(() => {
                    $img.attr('src', getImagePath(obj));
                    $slot.removeClass('flashing').addClass('revealing');
                    setTimeout(() => $slot.removeClass('tier-transition revealing'), 2000);
                }, 300);
            }
            
            function upgradeObject() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                const cost = getCost(obj, 'upgrade');
                if (state.credits < cost) return;
                
                playPopSfx();
                state.credits -= cost;
                const previousTier = getObjectTier(obj.level);
                obj.level++;
                const newTier = getObjectTier(obj.level);
                
                const upgrades = [
                    () => { obj.tickValue = Math.max(2, Math.floor(obj.tickValue * 2.69)) + 25; return 'Tick value increased!'; },
                    () => { 
                        if (obj.breakProbability > 5) {
                            obj.breakProbability = Math.max(5, obj.breakProbability - 4);
                        } else {
                            obj.breakProbability = Math.max(0.01, obj.breakProbability * 0.99);
                        }
                        return 'Break chance reduced!'; 
                    },
                    () => { obj.shatterBonus = Math.floor(obj.shatterBonus * 2.69); return 'Shatter bonus increased!'; },
                    () => { 
                        if (obj.cooldown > 2) {
                            obj.cooldown = Math.max(2, obj.cooldown - 2);
                        } else {
                            obj.cooldown = Math.max(0.01, obj.cooldown * 0.99);
                        }
                        return 'Cooldown reduced!'; 
                    }
                ];
                
                let feedbackMessage = upgrades[Math.floor(Math.random() * 4)]();
                
                if (previousTier !== newTier) {
                    const $slot = $(`.object-slot[data-index="0"]`);
                    if ($slot.length) performTierTransition(obj, $slot);
                    
                    const tierNames = { orbs: 'Shape â†’ Orb!', places: 'Orb â†’ Place!', realities: 'Place â†’ Reality!' };
                    feedbackMessage = `Tier upgrade: ${tierNames[newTier.name] || feedbackMessage}`;
                }
                
                showFeedback(feedbackMessage, 'success');
                saveGame(); updateUI();
            }
            
            function refreshCooldown() {
                const obj = state.objects[0];
                if (obj.isEmpty || !isOnCooldown(0)) return;
                const cost = getCost(obj, 'refresh');
                if (state.credits < cost) return;
                
                playPopSfx();
                state.credits -= cost; obj.lastTicked = null;
                clearCooldown(0); updateCooldownDisplay(0);
                showFeedback('Cooldown refreshed!', 'success');
                saveGame(); updateUI();
            }
            
            function chargeSubtick() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                
                if (obj.level >= 10) {
                    if (isDraining) return;
                    const cost = getCost(obj, 'subtick');
                    if (state.credits < cost || cost <= 0) return;
                    
                    isDraining = true;
                    $('#subtickButton').addClass('draining');
                    
                    drainInterval = setInterval(() => {
                        const currentCost = getCost(obj, 'subtick');
                        if (state.credits < currentCost || currentCost <= 0) {
                            stopProcess('drain');
                            return;
                        }
                        
                        playPopSfx();
                        state.credits -= currentCost;
                        obj.subtickCount++;
                        saveGame(); updateUI();
                    }, 100);
                    
                    showFeedback('Full Charge activated!', 'success');
                } else {
                    const cost = getCost(obj, 'subtick');
                    if (state.credits < cost || cost <= 0) return;
                    
                    playPopSfx();
                    state.credits -= cost; obj.subtickCount++;
                    showFeedback('Subtick charged!', 'success');
                    saveGame(); updateUI();
                }
            }
            
            function resetObject(obj) {
                autoClickEnabled = false;
                $('#autoButton').removeClass('active');
                stopProcess('drain');
                stopProcess('upgrade');
                Object.assign(obj, createEmptyObject());
            }
            
            function discardObject() {
                const obj = state.objects[0];
                if (obj.isEmpty) return;
                if (obj.currentMusic) stopMusic();
                clearCooldown(0); playBreakSfx(obj.breakSfx);
                resetObject(obj);
                saveGame(); updateUI(); showFeedback('Object discarded!', 'warning');
            }
            
            function isOnCooldown(idx) {
                const obj = state.objects[idx];
                return obj.lastTicked && (Date.now() - obj.lastTicked) < (obj.cooldown * 1000);
            }
            
            function getCooldownRemaining(idx) {
                const obj = state.objects[idx];
                if (!obj.lastTicked) return 0;
                return Math.max(0, (obj.cooldown * 1000) - (Date.now() - obj.lastTicked));
            }
            
            function clearCooldown(idx) {
                if (cooldownIntervals.has(idx)) { 
                    clearInterval(cooldownIntervals.get(idx)); 
                    cooldownIntervals.delete(idx); 
                }
            }
            
            function startCooldownTimer(idx) {
                const obj = state.objects[idx];
                if (obj.isEmpty) return;
                clearCooldown(idx);
                const interval = setInterval(() => {
                    if (isOnCooldown(idx)) {
                        updateCooldownDisplay(idx);
                    } else {
                        clearCooldown(idx);
                        updateCooldownDisplay(idx);
                        if (autoClickEnabled && idx === 0 && !obj.isEmpty) tickObject(idx);
                    }
                }, 100);
                cooldownIntervals.set(idx, interval);
            }
            
            function updateCooldownDisplay(idx) {
                const $slot = $(`.object-slot[data-index="${idx}"]`);
                const remaining = getCooldownRemaining(idx);
                
                if (remaining > 0) {
                    const obj = state.objects[idx];
                    const progress = ((obj.cooldown * 1000 - remaining) / (obj.cooldown * 1000)) * 100;
                    $slot.addClass('cooldown').find('.cooldown-bar').css('width', `${progress}%`);
                    $slot.find('.cooldown-text').text(`${formatDecimal(remaining / 1000, 's')}`).show();
                } else {
                    $slot.removeClass('cooldown').find('.cooldown-bar').css('width', '0%');
                    $slot.find('.cooldown-text').hide();
                }
            }
            
            function tickObject(idx) {
                const obj = state.objects[idx];
                if (obj.isEmpty || isOnCooldown(idx)) return;
                
                if (obj.subtickCount > 0) {
                    const subtickCredits = obj.tickValue * obj.subtickCount;
                    state.credits += subtickCredits;
                    showFeedback(`${obj.subtickCount} subticks: +${formatNumber(subtickCredits)}!`, 'success');
                    obj.subtickCount = 0;
                }
                
                state.credits += obj.tickValue;
                showFeedback(`+${formatNumber(obj.tickValue)}!`, 'success');
                obj.lastTicked = Date.now();
                startCooldownTimer(idx);
                
                if (Math.random() * 100 < obj.breakProbability) {
                    state.credits += obj.shatterBonus;
                    showFeedback(`Object shattered! +${formatNumber(obj.shatterBonus)} bonus!`, 'warning');
                    playBreakSfx(obj.breakSfx);
                    if (obj.currentMusic) stopMusic();
                    clearCooldown(idx);
                    resetObject(obj);
                } else {
                    playTickSfx((obj.breakSfx % 3) + 1);
                }
                saveGame(); updateUI();
            }
            
            function fillEmptySlot(idx) {
                const obj = state.objects[idx];
                if (!obj.isEmpty) return;
                
                const newObj = generateObj();
                Object.assign(obj, newObj);
                obj.isEmpty = false; obj.currentMusic = true;
                
                const bonuses = [
                    { thresholds: [5, 15, 25, 35, 45], prop: 'cooldown' },
                    { thresholds: [20, 30, 40], prop: 'breakProbability' }
                ];
                
                bonuses.forEach(({ thresholds, prop }) => {
                    thresholds.forEach(threshold => {
                        if (obj[prop] > threshold) obj.tickValue *= 2;
                    });
                });
                
                stopMusic(); playMusic(obj.music);
                saveGame(); updateUI(); showFeedback('New object', 'success');
            }
            
            function showFeedback(msg, type = 'success') {
                const $fb = $('#feedback');
                $fb.removeClass('success warning error').addClass(type).text(msg).addClass('show');
                setTimeout(() => $fb.removeClass('show'), 3000);
            }
            
            function updateUI() {
                $('#creditAmount').text(formatNumber(state.credits));
                const obj = state.objects[0];
                const buttons = { 
                    upgrade: $('#upgradeButton'), 
                    refresh: $('#refreshButton'), 
                    subtick: $('#subtickButton') 
                };
                const $discard = $('#discardButton'), $auto = $('#autoButton');
                const $level = $('#objectLevel'), $meter = $('#subtickMeter');
                
                if (obj.isEmpty) {
                    Object.values(buttons).forEach(btn => btn.hide());
                    $discard.hide(); $auto.hide(); $meter.hide(); $level.text('Level 1');
                } else {
                    const costs = {
                        upgrade: getCost(obj, 'upgrade'),
                        refresh: getCost(obj, 'refresh'),
                        subtick: getCost(obj, 'subtick')
                    };
                    
                    const upgradeText = isAutoUpgrading ? 'Auto Upgrade' : 'Upgrade';
                    buttons.upgrade.show().text(`${upgradeText} - ${formatNumber(costs.upgrade)}`)
                        .prop('disabled', state.credits < costs.upgrade);
                    
                    $discard.show(); $level.text(`Level ${obj.level}`);
                    
                    if (obj.level >= 20) $auto.show();
                    else $auto.hide();
                    
                    if (obj.level > 2) {
                        buttons.refresh.show().text(`Refresh - ${formatNumber(costs.refresh)}`)
                            .prop('disabled', state.credits < costs.refresh || !isOnCooldown(0));
                    } else buttons.refresh.hide();
                    
                    if (obj.level > 4) {
                        const buttonText = obj.level >= 10 ? 'Full Charge' : 'Charge Subtick';
                        const canAfford = state.credits >= costs.subtick && costs.subtick > 0;
                        const isDisabled = !canAfford || isDraining;
                        
                        buttons.subtick.show().text(`${buttonText} - ${formatNumber(costs.subtick)}`)
                            .prop('disabled', isDisabled);
                        $meter.show().text(`Subticks: ${obj.subtickCount}`);
                    } else { 
                        buttons.subtick.hide(); 
                        $meter.hide(); 
                    }
                }
                renderSlots();
            }
            
            function renderSlots() {
                const $grid = $('#objectsGrid');
                $grid.empty();
                
                state.objects.forEach((obj, idx) => {
                    const $slot = $('<div>').addClass('object-slot').attr('data-index', idx);
                    
                    if (obj.isEmpty) {
                        $slot.addClass('empty').html('<div>Click for a new object</div>')
                            .on('click', () => fillEmptySlot(idx));
                    } else {
                        $slot.addClass('filled');
                        const imagePath = getImagePath(obj);
                        const $img = $('<img>').addClass('object-image').attr('src', imagePath)
                            .attr('alt', `Object ${obj.imageNumber}`)
                            .on('error', function() { 
                                $(this).attr('src', 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSIjNGE0YTRhIi8+Cjx0ZXh0IHg9IjUwIiB5PSI1NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzk0YTNiOCIgZm9udC1zaXplPSIxMiI+Tm90IEZvdW5kPC90ZXh0Pgo8L3N2Zz4='); 
                            });
                        
                        const tier = getObjectTier(obj.level);
                        const tierDisplay = tier.name.charAt(0).toUpperCase() + tier.name.slice(1, -1);
                        
                        const stats = [
                            ['Tier', tierDisplay],
                            ['Level', obj.level],
                            ['Tick', formatNumber(obj.tickValue)],
                            ['Break', formatDecimal(obj.breakProbability, '%')],
                            ['Shatter', formatNumber(obj.shatterBonus)],
                            ['Cooldown', formatDecimal(obj.cooldown, 's')]
                        ];
                        
                        if (obj.subtickCount > 0) stats.push(['Subticks', obj.subtickCount]);
                        
                        const statsHTML = stats.map(([label, value]) => 
                            `<div class="stat-row"><span class="stat-label">${label}:</span><span class="stat-value">${value}</span></div>`
                        ).join('');
                        
                        const $stats = $('<div>').addClass('object-stats').html(statsHTML);
                        const $cooldownBar = $('<div>').addClass('cooldown-bar');
                        const $cooldownText = $('<div>').addClass('cooldown-text').hide();
                        
                        $slot.append($img, $stats, $cooldownBar, $cooldownText).on('click', () => {
                            if (!isOnCooldown(idx)) {
                                $slot.addClass('pulsing');
                                setTimeout(() => $slot.removeClass('pulsing'), 500);
                                tickObject(idx);
                            }
                        });
                        
                        updateCooldownDisplay(idx);
                        if (isOnCooldown(idx)) startCooldownTimer(idx);
                    }
                    $grid.append($slot);
                });
            }
            
            function init() {
                const saved = loadGame();
                if (saved) {
                    state = saved;
                    const obj = state.objects[0];
                    if (!obj.isEmpty && obj.currentMusic && !state.isMuted) playMusic(obj.music);
                } else {
                    showFeedback('Save reset - creating new game', 'warning');
                }
                
                const $mute = $('#muteButton');
                $mute.text(state.isMuted ? 'ðŸ”‡' : 'ðŸ”Š')[state.isMuted ? 'addClass' : 'removeClass']('muted');
                
                // Event handlers
                $mute.on('click', toggleMute);
                
                const $upgradeButton = $('#upgradeButton');
                let upgradeHoldStart = null, isHeld = false, touchHandled = false;
                
                $upgradeButton.on('mousedown touchstart', function(e) {
                    e.preventDefault();
                    
                    if (e.type === 'touchstart') {
                        touchHandled = true;
                    } else if (e.type === 'mousedown' && touchHandled) {
                        return;
                    }
                    
                    isHeld = false;
                    if (upgradeHoldTimer) clearTimeout(upgradeHoldTimer);
                    upgradeHoldStart = Date.now();
                    
                    upgradeHoldTimer = setTimeout(() => {
                        const obj = state.objects[0];
                        if (obj.isEmpty || state.credits < getCost(obj, 'upgrade')) return;
                        
                        isHeld = true;
                        isAutoUpgrading = true;
                        $('#upgradeButton').addClass('auto-upgrading');
                        
                        autoUpgradeInterval = setInterval(() => {
                            const obj = state.objects[0];
                            if (obj.isEmpty || state.credits < getCost(obj, 'upgrade')) {
                                stopProcess('upgrade');
                                return;
                            }
                            upgradeObject();
                        }, 100);
                        
                        showFeedback('Auto Upgrade activated!', 'success');
                    }, 2000);
                });
                
                $(document).on('mouseup touchend', function(e) {
                    if (e.type === 'touchend') {
                        setTimeout(() => { touchHandled = false; }, 100);
                    } else if (e.type === 'mouseup' && touchHandled) {
                        return;
                    }
                    
                    if (upgradeHoldTimer) {
                        clearTimeout(upgradeHoldTimer);
                        upgradeHoldTimer = null;
                    }
                    
                    if (!isHeld && upgradeHoldStart) {
                        const heldDuration = Date.now() - upgradeHoldStart;
                        if (heldDuration < 2000) upgradeObject();
                    }
                    
                    upgradeHoldStart = null;
                });
                
                $upgradeButton.on('click', function(e) {
                    if (!isAutoUpgrading) upgradeObject();
                });
                
                $('#refreshButton').on('click', refreshCooldown);
                $('#subtickButton').on('click', chargeSubtick);
                $('#discardButton').on('click', discardObject);
                $('#autoButton').on('click', toggleAuto);
                
                updateUI();
                setInterval(saveGame, 5000);
            }
            
            init();
        });
    </script>
</body>
</html>